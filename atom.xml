<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sin5&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sin5th.com/"/>
  <updated>2017-05-15T05:51:19.000Z</updated>
  <id>http://blog.sin5th.com/</id>
  
  <author>
    <name>武鑫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017-05-15</title>
    <link href="http://blog.sin5th.com/2017/05/15/2017-05-15/"/>
    <id>http://blog.sin5th.com/2017/05/15/2017-05-15/</id>
    <published>2017-05-15T05:36:50.000Z</published>
    <updated>2017-05-15T05:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hr-sect">Hack ╮(￣▽￣)╭ News</div>

<h1 id="对抗职业疲劳"><a href="#对抗职业疲劳" class="headerlink" title="对抗职业疲劳"></a>对抗职业疲劳</h1><p><a href="https://kierantie.com/a/burnout/" target="_blank" rel="external">链接地址</a></p>
<p>工作体面、薪水满意、压力合适…为什么还是遭遇了职业疲劳。Drs. Michael P. Leitner 和 Christina Maslach 的 《The Truth About Burnout》概括了 6 个关键点：</p>
<ol>
<li>话语权</li>
<li>价值观</li>
<li>薪酬待遇</li>
<li>工作量</li>
<li>职业发展</li>
<li>交流环境</li>
</ol>
<p>作者说他为了应对职业疲劳采取过休假、交流等等方式，但都不见成效。最后，彻底地改换了工作，成为了一名自由职业者。</p>
<p>在文中的最后，作者告诫我们：</p>
<ul>
<li>不要讳疾忌医，正确看待自己的职业疲劳</li>
<li>耐心应对，从疲劳中恢复是个漫长的过程</li>
<li>提早预防，治疗的效果永远比不上治疗</li>
</ul>
<div class="hr-sect">Tech (￣▽￣)~* Learning</div>



<div class="hr-sect">Book ╰(￣▽￣)╭ Reading</div>



<div class="hr-sect">Idea (～￣▽￣)～ Spreading</div>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hr-sect&quot;&gt;Hack ╮(￣▽￣)╭ News&lt;/div&gt;

&lt;h1 id=&quot;对抗职业疲劳&quot;&gt;&lt;a href=&quot;#对抗职业疲劳&quot; class=&quot;headerlink&quot; title=&quot;对抗职业疲劳&quot;&gt;&lt;/a&gt;对抗职业疲劳&lt;/h1&gt;&lt;p&gt;&lt;a href=
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-14</title>
    <link href="http://blog.sin5th.com/2017/05/14/2017-05-14/"/>
    <id>http://blog.sin5th.com/2017/05/14/2017-05-14/</id>
    <published>2017-05-14T03:47:03.000Z</published>
    <updated>2017-05-14T10:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hr-sect">Hack ╮(￣▽￣)╭ News</div>

<h1 id="无意间制止-wannacrypt-的始末"><a href="#无意间制止-WannaCrypt-的始末" class="headerlink" title="无意间制止 WannaCrypt 的始末"></a>无意间制止 WannaCrypt 的始末</h1><p><a href="https://www.malwaretech.com/2017/05/how-to-accidentally-stop-a-global-cyber-attacks.html" target="_blank" rel="external">链接地址</a></p>
<p>MalwareTech 发表博文讲述与 WannaCrypt 对抗的全过程。由于外界媒体在报道过程中多用 <em>accident</em> 一词，作者也颇具嘲讽意味地沿用了这种表述。当然，作者的表现充分体现了一名系统安全人员的职业素养，并没有任何偶然、碰巧的因素。</p>
<p>作者观察到被绑架的计算机试图连接一个未经注册的域名，凭借经验与直觉，他意识到这个域名的特殊意义，并抢先注册，将其指向 <strong>sinkhole servers</strong>。而此举恰恰阻止了蠕虫的传播。</p>
<p>事情解决之后，作者总结措施生效的原因。在开发蠕虫的沙盒环境中，这个未经注册的域名作为保护手段来及时地停止程序运行。前人也曾用过这类方法。</p>
<p>后继，恶意软件开发团队释放了新版本来绕过这个问题。</p>
<div class="hr-sect">Tech (￣▽￣)~* Learning</div>



<div class="hr-sect">Book ╰(￣▽￣)╭ Reading</div>



<div class="hr-sect">Idea (～￣▽￣)～ Spreading</div>

<h1 id="工作中需要那么多条条框框吗"><a href="#工作中需要那么多条条框框吗" class="headerlink" title="工作中需要那么多条条框框吗"></a>工作中需要那么多条条框框吗</h1><p><a href="http://open.163.com/movie/2017/2/7/J/MC9GRQOVM_MC9GS3S7J.html" target="_blank" rel="external">链接地址</a></p>
<p>主讲人先是介绍了生产力对于人类社会的意义————生产力每年提升3%的情况下，下一代所享受到的成果将是现在的两倍(1.03^25)。但工作中的协作效率却因为 <strong>清晰度</strong>、<strong>衡量</strong>、<strong>问责</strong> 而降低。</p>
<p>主讲人推崇模糊的职责边界，少一点推脱，多一点承担。</p>
<p>个人想法</p>
<blockquote>
<p>之前看过一本书（或者演讲）：开发的效果没有标准，于是找来测试；测试的结果没人确认，于是找来运维…一层监视一层。</p>
<p>虽然我肯定职责细分的价值，但要不要那么多加强型、辅助型的角色，还是要仔细斟酌。最根本的原因是，1个诸葛亮抵得过300个臭裨将。</p>
<p>另外，怀疑尽职用心的人，相当于泼冷水；怀疑不尽职的人，有用吗？</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hr-sect&quot;&gt;Hack ╮(￣▽￣)╭ News&lt;/div&gt;

&lt;h1 id=&quot;无意间制止-wannacrypt-的始末&quot;&gt;&lt;a href=&quot;#无意间制止-WannaCrypt-的始末&quot; class=&quot;headerlink&quot; title=&quot;无意间制止 
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-13</title>
    <link href="http://blog.sin5th.com/2017/05/13/2017-05-13/"/>
    <id>http://blog.sin5th.com/2017/05/13/2017-05-13/</id>
    <published>2017-05-13T12:51:17.000Z</published>
    <updated>2017-05-14T03:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hr-sect">Hack ╮(￣▽￣)╭ News</div>

<h1 id="正确理解-cpu-利用率"><a href="#正确理解-CPU-利用率" class="headerlink" title="正确理解 CPU 利用率"></a>正确理解 CPU 利用率</h1><p><a href="http://www.brendangregg.com/blog/2017-05-09/cpu-utilization-is-wrong.html" target="_blank" rel="external">链接地址</a></p>
<p>Brendan Gregg 发布博文，指出<strong>常见的 CPU 利用率计算方式</strong>有误导性，是仅仅通过追踪 idle 进程占用 CPU 时间的比例得出的结果。</p>
<p>而实际程序瓶颈是否在 CPU，不能仅仅根据这个指标来判定，因为 stalled 状态的进程也被算在其中，在内存访问很多时，这种进程并没有真正地利用 CPU 去进行运算，而是将时间都耗费在等待内存上。</p>
<blockquote>
<p>我们以为的 90% CPU 都在工作<br><img src="/images/www.brendangregg.com/cpubusyidle.png" alt="busy"><br>实际上它们都卡住了<br><img src="/images/www.brendangregg.com/cpubusystalledidle.png" alt="stalled"></p>
</blockquote>
<p>因此，评价 CPU 究竟使用了多少，应该参考 IPC（instructions per cycle）这个指标，它描述 cpu 真正执行指令的时间占比。</p>
<p>网友对此观点有赞许，也有质疑。质疑声集中在对<strong>利用率</strong>一词的理解。</p>
<div class="hr-sect">Tech (￣▽￣)~* Learning</div>



<div class="hr-sect">Book ╰(￣▽￣)╭ Reading</div>



<div class="hr-sect">Idea (～￣▽￣)～ Spreading</div>

<h1 id="找到自己钟爱的工作"><a href="#找到自己钟爱的工作" class="headerlink" title="找到自己钟爱的工作"></a>找到自己钟爱的工作</h1><p><a href="http://open.163.com/movie/2017/2/H/M/MC9GRQOVM_MC9GSHHHM.html" target="_blank" rel="external">视频地址</a></p>
<p>你如何选择工作？是追求简历的华丽，还是渴望愉悦的生活。演讲人告诫我们，“喝醉烈的酒，恋最美的人”，与有理想、有抱负的人一起工作。</p>
<p>另外，演讲人还说，想做到成功，请参考以下 3 点：</p>
<ol>
<li>特长</li>
<li>价值</li>
<li>经验</li>
</ol>
<p>个人想法</p>
<blockquote>
<p>虽然主讲人讲的绘声绘色，告诉我们成功需要哪些要素。但他忽略了一点（其实他意识到了那个东西），就是目标。</p>
<p>许多人不是没有目标，而是目标太低了。只想普普通通地过生活，这对他们而言，就已经是成功了。</p>
</blockquote>
<p>另外，我越发相信 <strong>1分天才，9分努力，90分运气</strong>。因为你是否愿意去努力，很大程度上取决于你（从出生到现在）接触过的人与事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hr-sect&quot;&gt;Hack ╮(￣▽￣)╭ News&lt;/div&gt;

&lt;h1 id=&quot;正确理解-cpu-利用率&quot;&gt;&lt;a href=&quot;#正确理解-CPU-利用率&quot; class=&quot;headerlink&quot; title=&quot;正确理解 CPU 利用率&quot;&gt;&lt;/a&gt;正确理解
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-12</title>
    <link href="http://blog.sin5th.com/2017/05/12/2017-05-12/"/>
    <id>http://blog.sin5th.com/2017/05/12/2017-05-12/</id>
    <published>2017-05-12T06:05:30.000Z</published>
    <updated>2017-05-12T10:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hr-sect">Hack ╮(￣▽￣)╭ News</div>

<h1 id="solar-roof-太阳能屋顶"><a href="#Solar-Roof-太阳能屋顶" class="headerlink" title="Solar Roof 太阳能屋顶"></a>Solar Roof 太阳能屋顶</h1><p><a href="https://www.tesla.com/blog/solar-roof" target="_blank" rel="external">链接地址</a></p>
<p>特斯拉发表博文，宣传其太阳能屋顶。卖点如下：</p>
<ul>
<li>不贵，算上省下的电钱，甚至比普通砖便宜</li>
<li>好看，提供了许多（4种）样式</li>
<li>耐用，钢化玻璃做的，比沥青和混凝土好</li>
<li>好买，官网订就行了</li>
</ul>
<p>但网友似乎对此并不买账，均表示“哪里不贵？”。据核算，特斯拉太阳能屋顶所节约的费用，至少累积30年才抵得上多花的费用，考虑通货膨胀大概在40年左右；另一个角度是，置办一套太阳能发电都花不了这么多钱 (￣.￣)</p>
<div class="hr-sect">Tech (￣▽￣)~* Learning</div>



<div class="hr-sect">Book ╰(￣▽￣)╭ Reading</div>



<div class="hr-sect">Idea (～￣▽￣)～ Spreading</div>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hr-sect&quot;&gt;Hack ╮(￣▽￣)╭ News&lt;/div&gt;

&lt;h1 id=&quot;solar-roof-太阳能屋顶&quot;&gt;&lt;a href=&quot;#Solar-Roof-太阳能屋顶&quot; class=&quot;headerlink&quot; title=&quot;Solar Roof 太阳能
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-11</title>
    <link href="http://blog.sin5th.com/2017/05/11/2017-05-11/"/>
    <id>http://blog.sin5th.com/2017/05/11/2017-05-11/</id>
    <published>2017-05-11T02:18:18.000Z</published>
    <updated>2017-05-12T02:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>mozilla 发起活动，拯救网络自由</li>
<li>如何成为更好的交谈者</li>
</ul>
<a id="more"></a>
<div class="hr-sect">Hack News</div>

<h1 id="mozilla-发起活动拯救网络自由"><a href="#mozilla-发起活动，拯救网络自由" class="headerlink" title="mozilla 发起活动，拯救网络自由"></a>mozilla 发起活动，拯救网络自由</h1><p><a href="https://blog.mozilla.org/blog/2017/05/08/next-10-days-critical-internets-future/" target="_blank" rel="external">链接地址</a></p>
<p>美国联邦通信委员（FCC）会将于5月18日进行“废除网络中立”的投票。</p>
<p>在 Mozilla 看来，这项决定会严重影响网络的使用方式，比如：</p>
<ul>
<li>言论自由</li>
<li>公平竞争</li>
<li>技术革新</li>
<li>自由选择</li>
</ul>
<p>作为应对，Mozilla 号召人们参与“签名活动”，通过收集签名与录音的形式，将意见传递给 FCC。</p>
<p>评论中充满对网络运营商的担忧，担心他们垄断网络通道，榨取高额费用。</p>
<blockquote>
<p>从网友们的辩论中，意识到一件事：A引起B；B引起C；但减少A未必减少C。比如，运营商收费低造成互联网公司快速崛起并且趋于垄断，垄断导致新兴公司难以抗衡。但是运营商收费却对解决垄断毫无意义，甚至进一步提高了创业公司比肩大企业的门槛。</p>
</blockquote>
<div class="hr-sect">Tech Learning</div>



<div class="hr-sect">Book Reading</div>



<div class="hr-sect">Ideas Spreading</div>

<h1 id="如何成为更好的交谈者"><a href="#如何成为更好的交谈者" class="headerlink" title="如何成为更好的交谈者"></a>如何成为更好的交谈者</h1><p><a href="http://open.163.com/movie/2016/3/F/E/MBFLN6BJF_MBFLNJGFE.html" target="_blank" rel="external">链接地址</a></p>
<p>太多人经历过学习如何沟通，准备好话题、注视眼睛、点头微笑…这些看似实用的技巧，实际上却总适得其反，因为太假了。</p>
<p>视频中的主讲人说了10个关键点：</p>
<ol>
<li>不分神</li>
<li>不说教</li>
<li>不引导</li>
<li>不逗留</li>
<li>不乱讲</li>
<li>不述己</li>
<li>不重复</li>
<li>不废话</li>
<li>不多话</li>
<li>不冗余</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;mozilla 发起活动，拯救网络自由&lt;/li&gt;
&lt;li&gt;如何成为更好的交谈者&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-10</title>
    <link href="http://blog.sin5th.com/2017/05/10/2017-05-10/"/>
    <id>http://blog.sin5th.com/2017/05/10/2017-05-10/</id>
    <published>2017-05-10T02:10:39.000Z</published>
    <updated>2017-05-11T03:14:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>开始自己的音乐制作</li>
<li>进程间通信：消息队列、信号量、共享内存</li>
<li>git clone –depth</li>
<li>更好的方式迎接死亡</li>
</ul>
<a id="more"></a>
<div class="hr-sect">Hack News</div>

<h1 id="音乐制作"><a href="#音乐制作" class="headerlink" title="音乐制作"></a>音乐制作</h1><p><a href="https://learningmusic.ableton.com/index.html" target="_blank" rel="external">链接地址</a></p>
<p>很多音乐都是通过混合乐器声制作而成的，了解一些基本的知识，你也可以制作出动人的音乐。</p>
<p>常见的发声器有：</p>
<ul>
<li>hihat（脚踏钹）</li>
<li>snare（小鼓）</li>
<li>clap（击掌）</li>
<li>kick（大鼓）</li>
</ul>
<div class="hr-sect">Tech Learning</div>

<h1 id="git-shallow-clone"><a href="#git-shallow-clone" class="headerlink" title="git shallow clone"></a>git shallow clone</h1><p><a href="https://www.perforce.com/blog/141218/git-beyond-basics-using-shallow-clones" target="_blank" rel="external">链接地址</a></p>
<p>因为 git clone 不仅下载文件，还会下载每一个版本变更。在持续集成（CI）、持续交付（CD）中，自动化的下载容易引起 git 服务器负载问题。。</p>
<p><code>git clone --depth 1</code> 能简单地避免该问题。</p>
<p><em>Git 1.9 版本之前，shallow clone 的代码库不支持 pull/push。</em></p>
<div class="hr-sect">Book Reading</div>

<h1 id="apue-xsi-ipc"><a href="#APUE-XSI-IPC" class="headerlink" title="APUE XSI IPC"></a>APUE XSI IPC</h1><p>除了管道、命名管道之外，另外三种 IPC：</p>
<ul>
<li>消息队列</li>
<li>信号量</li>
<li>共享存储</li>
</ul>
<div class="hr-sect">Ideas Spreading</div>

<h1 id="更好的方式"><a href="#更好的方式" class="headerlink" title="更好的方式"></a>更好的方式</h1><p><a href="http://open.163.com/movie/2015/7/4/7/MAUJNN86J_MAUJO1D47.html" target="_blank" rel="external">视频地址</a></p>
<p>死亡，一个绝大多数人不想谈论的词，但也是所有人都将面临的事。</p>
<p>我们抵触它、避讳它，但却没能给我们带来什么真实的意义。医院是压抑的，疗养院是单调的…</p>
<p>火葬最初被99.8%的人所抵触，但最终还是为大多数人接受。所以，何不换一种方式看待死亡。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;开始自己的音乐制作&lt;/li&gt;
&lt;li&gt;进程间通信：消息队列、信号量、共享内存&lt;/li&gt;
&lt;li&gt;git clone –depth&lt;/li&gt;
&lt;li&gt;更好的方式迎接死亡&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-09</title>
    <link href="http://blog.sin5th.com/2017/05/09/2017-05-09/"/>
    <id>http://blog.sin5th.com/2017/05/09/2017-05-09/</id>
    <published>2017-05-09T08:30:52.000Z</published>
    <updated>2017-05-11T03:13:51.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>Uber 涉嫌使用软件躲避审查，受到法律调查</li>
<li>如何掌控你的自由时间</li>
<li>go 中的继承</li>
</ul>
<a id="more"></a>
<div class="hr-sect">Hack News</div>

<h1 id="uber-受到法律调查"><a href="#Uber-受到法律调查" class="headerlink" title="Uber 受到法律调查"></a>Uber 受到法律调查</h1><p><a href="http://www.reuters.com/article/us-uber-tech-crime-exclusive-idUSKBN1802U1" target="_blank" rel="external">链接地址</a><br>Uber 涉嫌利用 Greyball 软件，协助司机躲避监管，受到司法部的调查。</p>
<p>称其通过挖掘信用卡、地理位置等信息，辨识用户身份，并进一步阻碍监管人员“钓鱼执法”。</p>
<p>最近，Uber 商业及法律问题不断，引起众多社会舆论。</p>
<p>该调查不代表任何违法事件的发生。</p>
<div class="hr-sect">Tech Learning</div>

<h1 id="inherition-in-go"><a href="#inherition-in-go" class="headerlink" title="inherition in go"></a>inherition in go</h1><p>首先，golang 不支持类与继承。</p>
<p>但我们总会遇到这样的场景，有一种对象 A，它包含许多属性与方法的定义。现在需要一种对象 B，它和 A 几乎相同，只在一个方法上略有不同。</p>
<p>如果是 c++/java 出身，会自然地写出类似下面的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">  attr_a;</div><div class="line">  attr_b;</div><div class="line">  method_a;</div><div class="line">  method_b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B(A) &#123;</div><div class="line">  method_b; // another implementation</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是 js/lua 出身，会自然地写出类似下面的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ProtoTypeA = &#123;</div><div class="line">  method_a;</div><div class="line">  method_b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function A(attr_a, attr_b)&#123;</div><div class="line">  o = new object;</div><div class="line">  o.attr_a = attr_a;</div><div class="line">  o.attr_b = attr_b;</div><div class="line">  set_prototype(o, ProtoTypeA);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ProtoTypeB = &#123;</div><div class="line">  method_b; // another implementation</div><div class="line">&#125;</div><div class="line"></div><div class="line">set_prototype(ProtoTypeB, ProtoTypeA)</div><div class="line"></div><div class="line">function B(attr_a, attr_b)&#123;</div><div class="line">  o = A(attr_a, attr_b);</div><div class="line">  set_prototype(o, ProtoTypeB)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相比js/lua(基于原型)的继承，c++/java 这种(基于类)看起来更直观。但 go 与这两者都不同，它是基于组合的。</p>
<p>由于嵌入类的使用特性，go 允许出现类似 c++/java 中的定义方式，但实际效果差别极大。<br>在下述定义中，b.in_A_B() 是合法的调用，但这仅仅是个语法糖，是 b.A.in_A_B() 的缩写。因此它会返回 “A” 而不是 “B”。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span><span class="title">in_A_B</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> a.in_What()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span><span class="title">in_What</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"A"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</div><div class="line">	A</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span><span class="title">in_What</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"B"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = B&#123;&#125;</div><div class="line">b.in_A_B()</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果想达到类似的效果，可以声明一个代理函数，然后在实例初始化过程中（当然，这个过程是自己规划出来的）对代理函数进行赋值（这一步有点像 js/lua），不过还是比较受限且麻烦的。<br>*先到这里，没来得及思考、查阅更好的方法。或许 golang 根本不鼓励这种玩法也说不定。</p>
</blockquote>
<div class="hr-sect">Book Reading</div>



<p><div class="hr-sect">Ideas Spreading</div></p>
<h1 id="如何掌控你的自由时间"><a href="#如何掌控你的自由时间" class="headerlink" title="如何掌控你的自由时间"></a>如何掌控你的自由时间</h1><p><a href="http://open.163.com/movie/2016/12/I/B/MC82BCQAN_MC8U8L3IB.html" target="_blank" rel="external">视频地址</a><br>我们总说把握好时间，就能过上想要的生活。事实是，先有想要怎样的生活，才会去安排时间。</p>
<p>与其说“没有时间”，不如说“我不想把时间花费在这件事上”，所以，时间就是选择。</p>
<p>就如同那句老话：<em>时间就是海绵里的水，挤挤总是有的。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Uber 涉嫌使用软件躲避审查，受到法律调查&lt;/li&gt;
&lt;li&gt;如何掌控你的自由时间&lt;/li&gt;
&lt;li&gt;go 中的继承&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-08</title>
    <link href="http://blog.sin5th.com/2017/05/08/2017-05-08/"/>
    <id>http://blog.sin5th.com/2017/05/08/2017-05-08/</id>
    <published>2017-05-08T03:33:20.000Z</published>
    <updated>2017-05-11T03:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>GNU libstdc++ 的内存深坑</li>
<li>Unix 中的命名管道</li>
<li>阅读 net/http</li>
<li>被拒绝不可怕</li>
</ul>
<a id="more"></a>
<div class="hr-sect">Hack News</div>

<h1 id="标准库中的惊悚"><a href="#标准库中的惊悚" class="headerlink" title="标准库中的惊悚"></a>标准库中的惊悚</h1><p><a href="https://www.zerotier.com/blog/2017-05-05-theleak.shtml" target="_blank" rel="external">链接地址</a></p>
<p>原作者在一次客户升级任务中，惨遭 <em>内存泄漏</em> 毒手。</p>
<blockquote>
<p>风波初起，devops 工程师妙手“回春”，定期重启稳住状况，为原作者争取时间；</p>
<p>原作者天真烂漫，遍寻 “内存泄漏”；不着，质疑标准库，又对 <em>hyper-optimized C++ template origami</em> 望而却步；</p>
<p>猛忆起玄妙词语 <em>内存碎片</em>，一番实践却又功亏一篑；</p>
<p>万念俱灰，对标准库再起杀心。终发现 libstdc++ 内存分配深坑（它为了应对 <code>malloc is slow</code>，包裹了一层分配池，于是乎…）</p>
</blockquote>
<p>设置环境变量 GLIBCPP_FORCE_NEW 可以强制 libstdc++ 关闭内存分配池。：D</p>
<div class="hr-sect">Tech Learning</div>

<h1 id="nethttp-in-go"><a href="#net-http-in-go" class="headerlink" title="net/http in go"></a>net/http in go</h1><p><a href="http://tour.golang.org" target="_blank" rel="external">http://tour.golang.org</a> 看完以为就算 golang 入门了，读读标准库发觉还差得多。</p>
<h2 id="select-on-closed-chan"><a href="#select-on-closed-chan" class="headerlink" title="select on closed chan"></a><code>select</code> on closed chan</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 出自 net/http/client.go</span></div><div class="line"><span class="comment">// 当 cancel 被 close 之后，函数永远返回 true</span></div><div class="line">wasCanceled = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> &lt;-cancel:</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="appendl-another_l"><a href="#append-l-another-l…" class="headerlink" title="append(l, another_l…)"></a><code>append</code>(l, another_l…)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 出自 net/http/client_test.go</span></div><div class="line"><span class="comment">// append(b, buf[:n]...) 中 ... 是将数组或分片展开</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pedanticReadAll</span><span class="params">(r io.Reader)</span> <span class="params">(b []<span class="keyword">byte</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> bufa [<span class="number">64</span>]<span class="keyword">byte</span></div><div class="line">	buf := bufa[:]</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		n, err := r.Read(buf)</div><div class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Read: n=0 with err=nil"</span>)</div><div class="line">		&#125;</div><div class="line">		b = <span class="built_in">append</span>(b, buf[:n]...)</div><div class="line">		<span class="keyword">if</span> err == io.EOF &#123;</div><div class="line">			n, err := r.Read(buf)</div><div class="line">			<span class="keyword">if</span> n != <span class="number">0</span> || err != io.EOF &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Read: n=%d err=%#v after EOF"</span>, n, err)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> b, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> b, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="error-is-a-interface"><a href="#error-is-a-interface" class="headerlink" title="error is a interface"></a><code>error</code> is a interface</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 出自 net/http/client_test.go</span></div><div class="line"><span class="comment">// error 是一个接口，因此 checkErr == nil</span></div><div class="line"><span class="keyword">var</span> checkErr error</div><div class="line">c = &amp;Client&#123;CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> checkErr</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="chan-send-only-amp-receive-only"><a href="#chan-send-only-amp-receive-only" class="headerlink" title="chan send-only &amp; receive-only"></a><code>chan</code> send-only &amp; receive-only</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 出自 net/http/request.go</span></div><div class="line"><span class="comment">// &lt;-chan 代表只读管道，chan&lt;- 代表只写管道</span></div><div class="line">Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div></pre></td></tr></table></figure>
<div class="hr-sect">Book Reading</div>

<h1 id="apue-fifo"><a href="#APUE-FIFO" class="headerlink" title="APUE FIFO"></a>APUE FIFO</h1><p>命名管道是 Unix 进程间通信的另一手段。不同于 pipe 只能在有关联的进程中使用，fifo 允许任意两个（或多个）进程进行通信，不过 fifo 也是单向通信。</p>
<p>fifo 一般用来做两件事：</p>
<ol>
<li><p>复制输出流</p>
<blockquote>
<p>当需要多个程序同时处理一种输出时，可以使用 tee 和 fifo。<br>tee 会将输入内容同时输出到 stdout 和一个命名文件；<br>如果这个命名文件为 fifo 类型，则启动另一进程进行读取，即可达到所需的效果。</p>
</blockquote>
</li>
<li><p>客户-服务器进程通信</p>
<blockquote>
<p>服务器从一个众所周知的 fifo 文件读取，而客户端向该文件写入。</p>
<p><em>注：当没有进程以写入模式打开 fifo 文件时，读取进程将收到 EOF。为避免此问题，服务器进程一般以读写模式打开</em></p>
</blockquote>
</li>
</ol>
<div class="hr-sect">Ideas Spreading</div>

<h1 id="每天被拒绝"><a href="#每天被拒绝" class="headerlink" title="每天被拒绝"></a>每天被拒绝</h1><p><a href="http://open.163.com/movie/2017/2/6/B/MC918H30S_MC9VQJL6B.html" target="_blank" rel="external">视频地址</a><br>被拒绝时不逃跑，继续询问、争取，会有机会成功，或者找到通往成功的方向。</p>
<p>在请求别人时，主动说出别人的疑虑，会容易获得信任。</p>
<p>事情的成功，不一定在于水平，也可能在于争取。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;GNU libstdc++ 的内存深坑&lt;/li&gt;
&lt;li&gt;Unix 中的命名管道&lt;/li&gt;
&lt;li&gt;阅读 net/http&lt;/li&gt;
&lt;li&gt;被拒绝不可怕&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-07</title>
    <link href="http://blog.sin5th.com/2017/05/07/2017-05-07/"/>
    <id>http://blog.sin5th.com/2017/05/07/2017-05-07/</id>
    <published>2017-05-07T05:44:08.000Z</published>
    <updated>2017-05-11T03:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>使用 pipe 进行进程间通信</li>
<li>看 google 如何防止 JSON hijacking</li>
<li>自媒体与虚假信息</li>
<li>理解 bash 算数表达式的返回状态</li>
</ul>
<a id="more"></a>
<div class="hr-sect">Hack News</div>

<h1 id="为何-google-的-json-response-包含-while1-前缀"><a href="#为何-google-的-json-response-包含-while-1-前缀？" class="headerlink" title="为何 google 的 json response 包含 while(1) 前缀？"></a>为何 google 的 json response 包含 while(1) 前缀？</h1><p><a href="http://stackoverflow.com/questions/2669690/why-does-google-prepend-while1-to-their-json-responses" target="_blank" rel="external">链接地址</a></p>
<p>最佳答案表示，这是为了防止 <a href="http://haacked.com/archive/2009/06/25/json-hijacking.aspx" target="_blank" rel="external">JSON 劫持</a></p>
<blockquote>
<p>虽然恶意网站会因为同源限制无法跨域名发起 ajax 请求，但是仍然可以在 <code>&lt;script&gt;</code> 中加入链接，然后通过<a href="http://ejohn.org/blog/re-securing-json/" target="_blank" rel="external">重写全局的数组构造器和访问方式</a>来达到窃取信息的目的。</p>
<p>在一个正常的 ajax 请求中，有途径可以去除这些额外的前缀；而在 <code>&lt;script&gt;</code> 标签中，却会造成脚本无限循环或解释出错。</p>
</blockquote>
<p>有人追问为何不使用<code>CSRF-token</code>？热心网友回答</p>
<blockquote>
<p>谷歌这种体量的公司，用 CSRF-token 要考虑的问题有些多，而且很浪费资源。</p>
</blockquote>
<p>另有网友表示</p>
<blockquote>
<p>他会通过在服务器端检验 http header 来避免这种问题。（感觉可行，不过没有尝试过）</p>
</blockquote>
<div class="hr-sect">Tech Learning</div>

<h1 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h1><h2 id="扩展算数表达式的退出状态不代表正误"><a href="#扩展算数表达式的退出状态不代表正误" class="headerlink" title="扩展算数表达式的退出状态不代表正误"></a>扩展算数表达式的退出状态不代表正误</h2><p>在 bash 中，算数表达式的退出状态，并不总代表执行是否成功，也与表达式返回值相关。</p>
<p>(( 1/0 )) 报错，rc=1<br>(( 0 )) 正确，rc=1<br>(( 1 )) 正确，rc=0<br>当表达式正常运算时，返回状态与返回值相反。即，运算结果为0时，退出状态为1（表示false)；否则相反。</p>
<p><a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part2/07_1_test_constructs.html" target="_blank" rel="external">范例摘自</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(( 0 &amp;&amp; 1 ))                 <span class="comment"># 逻辑与</span></div><div class="line"><span class="built_in">echo</span> $?     <span class="comment"># 1     ***</span></div><div class="line"><span class="comment"># 然后 ...</span></div><div class="line"><span class="built_in">let</span> <span class="string">"num = (( 0 &amp;&amp; 1 ))"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$num</span>   <span class="comment"># 0</span></div><div class="line"><span class="comment"># 然而 ...</span></div><div class="line"><span class="built_in">let</span> <span class="string">"num = (( 0 &amp;&amp; 1 ))"</span></div><div class="line"><span class="built_in">echo</span> $?     <span class="comment"># 1     ***</span></div><div class="line"></div><div class="line"></div><div class="line">(( 200 || 11 ))              <span class="comment"># 逻辑或</span></div><div class="line"><span class="built_in">echo</span> $?     <span class="comment"># 0     ***</span></div><div class="line"><span class="comment"># ...</span></div><div class="line"><span class="built_in">let</span> <span class="string">"num = (( 200 || 11 ))"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$num</span>   <span class="comment"># 1</span></div><div class="line"><span class="built_in">let</span> <span class="string">"num = (( 200 || 11 ))"</span></div><div class="line"><span class="built_in">echo</span> $?     <span class="comment"># 0     ***</span></div><div class="line"></div><div class="line"></div><div class="line">(( 200 | 11 ))               <span class="comment"># 按位或</span></div><div class="line"><span class="built_in">echo</span> $?                      <span class="comment"># 0     ***</span></div><div class="line"><span class="comment"># ...</span></div><div class="line"><span class="built_in">let</span> <span class="string">"num = (( 200 | 11 ))"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$num</span>                    <span class="comment"># 203</span></div><div class="line"><span class="built_in">let</span> <span class="string">"num = (( 200 | 11 ))"</span></div><div class="line"><span class="built_in">echo</span> $?                      <span class="comment"># 0     ***</span></div><div class="line"></div><div class="line"><span class="comment"># "let" 结构的退出状态与双括号算术扩展的退出状态相同。</span></div></pre></td></tr></table></figure></p>
<div class="hr-sect">Book Reading</div>

<h1 id="apue-进程间通信"><a href="#APUE-进程间通信" class="headerlink" title="APUE 进程间通信"></a>APUE 进程间通信</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><code>pipe</code> 函数将两个文件描述符关联起来，分别用作单工通信的输入、输出。使用时一般在父进程中调用，然后通过fork将文件描述符传递给子进程。</p>
<p><code>popen</code> 函数先调用pipe产生关联的文件描述符，之后调用fork和exec，将子进程的输出传回给调用进程。简化了管道的使用。</p>
<p>如果当前程序产生某个进程的输入，同时从该进程读取输出时，则称该进程为当前程序的协同进程。</p>
<div class="hr-sect">Ideas Spreading</div>

<h1 id="自媒体时代你能自己吗"><a href="#自媒体时代，你能自己吗？" class="headerlink" title="自媒体时代，你能自己吗？"></a>自媒体时代，你能自己吗？</h1><p><a href="http://open.163.com/movie/2017/5/9/9/MCIGB2D5E_MCIGB6K99.html" target="_blank" rel="external">视频地址</a></p>
<p>在通信技术日益发达的今天，我们每一个人都可以称作媒体，当我们点下 like 时，按下 share 时，都将声音传播了出去。</p>
<p>在自媒体时代，不再有人警告你“以下内容儿童不宜观看”，唯有洞察内心、增强分辨力才能不被世界的真真假假所摆布。</p>
<p>个人感受</p>
<blockquote>
<p>主讲人出身传统媒体，对自媒体的<strong>失控</strong>感到不适。列举了虚假内容传播的诸多事例，但流言这词却实非自媒体独有。我们不该把任何人当傻子看待，当大家对自媒体的信任程度趋于稳定时，当自媒体之间的差别被逐渐放大后，自媒体和传统媒体并没有本质上的差别。洗牌只是洗牌，不会多张牌、也不会少张牌，受影响的是持牌的玩家，但民众只是看客。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使用 pipe 进行进程间通信&lt;/li&gt;
&lt;li&gt;看 google 如何防止 JSON hijacking&lt;/li&gt;
&lt;li&gt;自媒体与虚假信息&lt;/li&gt;
&lt;li&gt;理解 bash 算数表达式的返回状态&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-06</title>
    <link href="http://blog.sin5th.com/2017/05/06/2017-05-06/"/>
    <id>http://blog.sin5th.com/2017/05/06/2017-05-06/</id>
    <published>2017-05-06T14:16:42.000Z</published>
    <updated>2017-05-11T03:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>如何做的更好</li>
<li>程序员的银行账户</li>
<li>js 预处理</li>
</ul>
<a id="more"></a>
<div class="hr-sect">Hack News</div>

<h1 id="可编程的银行账户"><a href="#可编程的银行账户" class="headerlink" title="可编程的银行账户"></a>可编程的银行账户</h1><p><a href="https://root.co.za/" target="_blank" rel="external">链接地址</a></p>
<p>借助 api 构建自己的使用接口，用程序管理钱。</p>
<h1 id="js-prepack"><a href="#js-prepack" class="headerlink" title="js prepack"></a>js prepack</h1><p><a href="https://prepack.io/" target="_blank" rel="external">链接地址</a></p>
<p>prepack 是一款用来优化 js 代码的工具，通过把编译期能确定下来的值计算出来；简化赋值过程；避免中间计算和对象分配；等等方式来提高 js 代码的性能质量。</p>
<blockquote>
<p>我始终认为代码质量是软件的关键指标之一，并且要分<code>维护性</code>、<code>运行性</code>这两个方面进行考量。维护性是为了让人清晰地理解，运行性是为了让机器清晰地理解。前人已经创造了许多减少二者摩擦的方法，比如预处理（中的宏定义）、注释（foo=3 # threads number)等等。prepack 也应属此类。</p>
</blockquote>
<p>卖水果的老农一阵嘀咕，云上便跑起一份代码。那时，我们终将明白：程序猿已逝，老鸟亦新雏。</p>
<div class="hr-sect">Tech Learning</div>



<div class="hr-sect">Book Reading</div>



<div class="hr-sect">Ideas Spreading</div>

<h1 id="如何做得更好"><a href="#如何做得更好" class="headerlink" title="如何做得更好"></a>如何做得更好</h1><p><a href="http://open.163.com/movie/2017/2/C/U/MCC01J0QP_MCC021ACU.html" target="_blank" rel="external">视频地址</a></p>
<p>高效的人和团队, 始终兼顾 <code>学习</code> 和 <code>执行</code>. 学习过程将注意力集中在未知的领域, 接受失败, 并转化为新的技能; 执行过程将注意力集中在已知的领域, 避免失败, 并产出成果.</p>
<p>太过关注成绩的学校, 驱使学生远离学习, 沉浸在执行中; 太过关注执行力的企业, 将员工限制在已知领域, 从而失去创新与进步.</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;如何做的更好&lt;/li&gt;
&lt;li&gt;程序员的银行账户&lt;/li&gt;
&lt;li&gt;js 预处理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-05</title>
    <link href="http://blog.sin5th.com/2017/05/05/2017-05-05/"/>
    <id>http://blog.sin5th.com/2017/05/05/2017-05-05/</id>
    <published>2017-05-04T16:02:41.000Z</published>
    <updated>2017-05-06T14:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hack-news"><a href="#hack-news" class="headerlink" title="hack news"></a>hack news</h1><h2 id="土耳其封锁维基百科"><a href="#土耳其封锁维基百科" class="headerlink" title="土耳其封锁维基百科"></a>土耳其封锁维基百科</h2><p><a href="https://turkeyblocks.org/2017/04/29/wikipedia-blocked-turkey/" target="_blank" rel="external">链接地址</a></p>
<p>当地时间4月29日, The Turkey Blocks 确认了对维基百科在线的封锁. 其声称根据行政管理指令, 维基百科在线被限制了所有语言版本的访问. 不久后升级为永久指令.</p>
<a id="more"></a>
<p>评论摘选<br><a href="https://news.ycombinator.com/user?id=RcouF1uZ4gsC" target="_blank" rel="external">RcouF1uZ4gsC</a></p>
<blockquote>
<p>2016年将是全球互联网的巅峰. 中国对互联网政治控制的成功, 与埃及/突尼斯被开放互联网推翻政权的失败形成对比, 一个开放/自由的互联网并不符合某些人的利益. 如果你觉着西方的民主自由幸免于此, 看看”虚假新闻”和”No Platform”. 我们正在从自由/开放的共享与讨论, 走向思想镇压(目前看来是个坏主意, 但未来就不一定了).</p>
<p>大量的网络内容控制在少数公司手中(如果 Google 和 Facebook 限制你的站点, 那你几乎不会有什么曝光度). 此外我们正在从用户控制的通用计算机, 向安全/移动监控设备方向发展. 政府可以通过对一些公司施压, 控制哪些信息可以流向民众.</p>
<p>为政府服务的&lt;第一修正案&gt;始终使用”危险”这个托词. 言论自由和法律同等重要. 如果我们被强大的非政府组织利用, 去镇压我们不喜欢的言论, 事实上就离被政府控制相距不远了.</p>
</blockquote>
<hr>
<h1 id="book-reading"><a href="#book-reading" class="headerlink" title="book reading"></a>book reading</h1><hr>
<h1 id="tech-learning"><a href="#tech-learning" class="headerlink" title="tech learning"></a>tech learning</h1><h2 id="go-的最佳实践"><a href="#go-的最佳实践" class="headerlink" title="go 的最佳实践"></a>go 的最佳实践</h2><p><a href="https://blog.rubylearning.com/best-practices-for-a-new-go-developer-8660384302fc" target="_blank" rel="external">链接地址</a><br>本人的技能入门套路是: quick start -&gt; tutorial -&gt; best practice<br>阅读最佳实践是必要的过程, 避免自学的弯路.</p>
<ol>
<li>面向对象 != 类与继承. golang 可以算是面向对象的语言, 但它表达的方式与 java/ruby/… 并不相同, 它仅提供 interface 特性满足开发者封装对象的需要.</li>
<li>组合 vs 继承. 这是一场语言无关的, 亘古持久的战争. 但不论是 <code>组合</code>, 还是 <code>继承</code>, 目的都是将 <code>代码</code> 转化成 <code>关系</code>, 减少代码量(常说的复用). 但从另一个角度讲, 组合是一种更加松散的关系, 很容易想到它的反义词–分离, 与分离之后依然健全的独立功能. 但继承的反义词–(并没有找到合适的词), 总让人有一种丧失根基的感觉.</li>
<li>Go Way. 每种语言都有它自己脾气. go 不是 java, 不是 ruby, 也不是 python, 所以 go 有它自己的写法. 不要试图去将过去的编程体验强行带入 go 中, 而是应该从 go 的角度出发, 理解为什么没有泛型/继承, 为什么有闭包/反射.</li>
<li>reading/writing/testing. 阅读标准库是学习语言的好途径, 如果是从其他语言转过来的, 找一个熟悉的模块能很快体会到 go 的玩法. 试着去解决遇到的问题, 动手写代码的同时, 写好文档和测试. go 语言提供了很好的测试支持.</li>
<li>标准库. go 的标准库比较完备, 初学者应该尽量使用, 不要过多地以来第三方库或者框架.</li>
</ol>
<hr>
<h1 id="ted"><a href="#ted" class="headerlink" title="ted"></a>ted</h1><h2 id="爱情应有的样子"><a href="#爱情应有的样子" class="headerlink" title="爱情应有的样子"></a>爱情应有的样子</h2><p><a href="http://open.163.com/movie/2017/2/D/7/MC9FQL66A_MCA50R4D7.html" target="_blank" rel="external">视频地址</a><br>爱常常让我们感到痛苦, 我们也习惯于用痛苦的多少, 衡量爱的深浅. 但爱本来是两个人合作经营的丰硕果实, 应当是愉快的. 让爱情回到它应有的样子, 让我们说 <code>世间最美好的事, 莫过于此</code> 或者 <code>爱情比我想象的短, 但还是很美好的</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hack-news&quot;&gt;&lt;a href=&quot;#hack-news&quot; class=&quot;headerlink&quot; title=&quot;hack news&quot;&gt;&lt;/a&gt;hack news&lt;/h1&gt;&lt;h2 id=&quot;土耳其封锁维基百科&quot;&gt;&lt;a href=&quot;#土耳其封锁维基百科&quot; class=&quot;headerlink&quot; title=&quot;土耳其封锁维基百科&quot;&gt;&lt;/a&gt;土耳其封锁维基百科&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://turkeyblocks.org/2017/04/29/wikipedia-blocked-turkey/&quot;&gt;链接地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当地时间4月29日, The Turkey Blocks 确认了对维基百科在线的封锁. 其声称根据行政管理指令, 维基百科在线被限制了所有语言版本的访问. 不久后升级为永久指令.&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-04</title>
    <link href="http://blog.sin5th.com/2017/05/04/2017-05-04/"/>
    <id>http://blog.sin5th.com/2017/05/04/2017-05-04/</id>
    <published>2017-05-04T14:28:45.000Z</published>
    <updated>2017-05-05T01:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天一直忙交接, 下午又接了个电话面试, 没腾出学习的时间. 看个 TED 睡了.</p>
<p>越发觉得自己太过实在, 甚至有些傻. 会做不会说, 不能愉快地 show.</p>
<a id="more"></a>
<h1 id="ted"><a href="#TED" class="headerlink" title="TED"></a>TED</h1><h2 id="高度科学的憎恨者分类法"><a href="#高度科学的憎恨者分类法" class="headerlink" title="高度科学的憎恨者分类法"></a>高度科学的憎恨者分类法</h2><p><a href="http://open.163.com/movie/2017/4/V/C/MCHRQ90VG_MCHRQBHVC.html" target="_blank" rel="external">视频地址</a></p>
<p>不像是演讲, 更像个脱口秀, 看了两遍也没能找到主旨, 大概是说 <em>社会正义喜剧</em> 很好看吧 ^.^</p>
<h2 id="知道自己该待在哪个圈子"><a href="#知道自己该待在哪个圈子" class="headerlink" title="知道自己该待在哪个圈子"></a>知道自己该待在哪个圈子</h2><p><a href="http://open.163.com/movie/2017/4/F/Q/MCI0S927E_MCI0SDJFQ.html" target="_blank" rel="external">视频地址</a></p>
<p>主讲人说了4个小故事, 依次描述了由内及外的四个圈:<br>舒适圈 ) 伸展圈 ) 恐慌圈 ) 恐慌圈之外</p>
<h3 id="选择公务员的高材生朋友"><a href="#选择公务员的高材生朋友" class="headerlink" title="选择公务员的高材生朋友"></a>选择公务员的高材生朋友</h3><blockquote>
<p>很有前途的朋友选择去当公务员, 让人不禁唏嘘. 然而一年后, 朋友发来信息, 表明自己在国安局, 每天和来自世界各地的黑客做对抗, 也很有意思. 另外, 由于职业要求, 进行了野外生存训练, 练就了6块腹肌.</p>
</blockquote>
<h3 id="开餐厅的学弟"><a href="#开餐厅的学弟" class="headerlink" title="开餐厅的学弟"></a>开餐厅的学弟</h3><blockquote>
<p>一个想开餐厅的学弟, 在冷冻加工厂工作之后, 苦修两年, 最终开启了自己的小店.</p>
</blockquote>
<h3 id="开餐厅的厨师朋友"><a href="#开餐厅的厨师朋友" class="headerlink" title="开餐厅的厨师朋友"></a>开餐厅的厨师朋友</h3><blockquote>
<p>擅长做菜的厨师朋友突然变身经营餐厅, 结果多次遭遇失败.</p>
</blockquote>
<h3 id="什么都不会的店长朋友"><a href="#什么都不会的店长朋友" class="headerlink" title="什么都不会的店长朋友"></a>什么都不会的店长朋友</h3><blockquote>
<p>什么都不擅长的朋友决心做店长, 本来不被看好的他却意外的顺利.</p>
</blockquote>
<p>用来说明下面这些道理: </p>
<ol>
<li>在舒适圈之内, 做我们力所能及的事情也可以精彩</li>
<li>从舒适圈中走出去, 做些精心细心的尝试, 也会有收获</li>
<li>和舒适圈不近不远, 反而可能因为角色转换不彻底而失败</li>
<li>离舒适圈足够远, 以尝试的心态做事, 同样能成功</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天一直忙交接, 下午又接了个电话面试, 没腾出学习的时间. 看个 TED 睡了.&lt;/p&gt;
&lt;p&gt;越发觉得自己太过实在, 甚至有些傻. 会做不会说, 不能愉快地 show.&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-03</title>
    <link href="http://blog.sin5th.com/2017/05/03/2017-05-03/"/>
    <id>http://blog.sin5th.com/2017/05/03/2017-05-03/</id>
    <published>2017-05-03T01:58:59.000Z</published>
    <updated>2017-05-03T14:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hack-news"><a href="#hack-news" class="headerlink" title="hack news"></a>hack news</h1><h2 id="乐高分类器"><a href="#乐高分类器" class="headerlink" title="乐高分类器"></a>乐高分类器</h2><p>原文地址: <a href="https://jacquesmattheij.com/sorting-two-metric-tons-of-lego" target="_blank" rel="external">https://jacquesmattheij.com/sorting-two-metric-tons-of-lego</a></p>
<p>作者突发奇想要做个乐高分类器, 在 ebay 上挂收购, 一不小心收多了, 就立马动手搞了起来.</p>
<p>从头到尾要面对挺多问题</p>
<ul>
<li>假货</li>
<li>褪色</li>
<li>坏损</li>
<li>脏污</li>
<li>稳定传送</li>
<li>扫描</li>
<li>判断优劣</li>
<li>按优劣分放</li>
</ul>
<a id="more"></a>
<p>作者最后的解决办法很有趣:<br>漏斗搭配一大一小两条履带, 把乐高从堆中依次运出, 经由摄像头成像. 使用神经算法区分优劣, 如果是劣质的, 就启动空气喷嘴, 吹到边上的桶里.</p>
<p>初见题目时, 以为是区分积木零件, 最后发现是区分优劣. 但也差不多, 还是很有趣的.<br>ps. 我小时候也很喜欢乐高, 拼个奥特曼飞机什么的. 好不好看不重要, 一定得有活动关节 ^.^</p>
<hr>
<h1 id="book-reading"><a href="#book-reading" class="headerlink" title="book reading"></a>book reading</h1><h2 id="apue-高级io"><a href="#apue-高级I-O" class="headerlink" title="apue 高级I/O"></a>apue 高级I/O</h2><p>之前见识过<code>非阻塞I/O</code>和<code>标准I/O</code>, <code>高级I/O</code>会是什么呢?</p>
<h2 id="第四次革命"><a href="#第四次革命" class="headerlink" title="第四次革命"></a>第四次革命</h2><p>哥白尼的日心说, 否定了地球是宇宙的中心<br>达尔文的进化论, 否定了人类是上帝的杰作<br>弗洛伊德的精神分析, 否定了人类的自主意识<br>图灵的计算模型, 否定了人类的独一无二  </p>
<hr>
<h1 id="ted"><a href="#ted" class="headerlink" title="ted"></a>ted</h1><h2 id="你发过短性息吗"><a href="#你发过“短性息”吗？" class="headerlink" title="你发过“短性息”吗？"></a>你发过“短性息”吗？</h2><p><a href="http://open.163.com/movie/2017/2/0/V/MCCS6ND1H_MCCSBPI0V.html" target="_blank" rel="external">链接地址</a><br>主讲人强调社会(法律/舆论)对 sexting 等”色情”产物的担忧不必要, 处理措施过于形式化.<br>更多的关注点应该放在”隐私”问题上, 即是否征得了隐私所有者的同意.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hack-news&quot;&gt;&lt;a href=&quot;#hack-news&quot; class=&quot;headerlink&quot; title=&quot;hack news&quot;&gt;&lt;/a&gt;hack news&lt;/h1&gt;&lt;h2 id=&quot;乐高分类器&quot;&gt;&lt;a href=&quot;#乐高分类器&quot; class=&quot;headerlink&quot; title=&quot;乐高分类器&quot;&gt;&lt;/a&gt;乐高分类器&lt;/h2&gt;&lt;p&gt;原文地址: &lt;a href=&quot;https://jacquesmattheij.com/sorting-two-metric-tons-of-lego&quot;&gt;https://jacquesmattheij.com/sorting-two-metric-tons-of-lego&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者突发奇想要做个乐高分类器, 在 ebay 上挂收购, 一不小心收多了, 就立马动手搞了起来.&lt;/p&gt;
&lt;p&gt;从头到尾要面对挺多问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假货&lt;/li&gt;
&lt;li&gt;褪色&lt;/li&gt;
&lt;li&gt;坏损&lt;/li&gt;
&lt;li&gt;脏污&lt;/li&gt;
&lt;li&gt;稳定传送&lt;/li&gt;
&lt;li&gt;扫描&lt;/li&gt;
&lt;li&gt;判断优劣&lt;/li&gt;
&lt;li&gt;按优劣分放&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-02</title>
    <link href="http://blog.sin5th.com/2017/05/02/2017-05-02/"/>
    <id>http://blog.sin5th.com/2017/05/02/2017-05-02/</id>
    <published>2017-05-02T01:52:18.000Z</published>
    <updated>2017-05-03T02:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hack-news"><a href="#hack-news" class="headerlink" title="hack news"></a>hack news</h1><h2 id="headless-chrome"><a href="#headless-chrome" class="headerlink" title="headless chrome"></a><a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank">headless chrome</a></h2><p>headless chrome 允许在不启动浏览器窗口的情况下, 测试浏览器的网页加载, 这对自动化测试提供了方便.</p>
<p>成文时, 稳定版的 chrome 刚刚48版本, 还不支持 headless, 需要安装 chrome canary.<br>mac os 可以使用 <code>brew install Caskroom/versions/google-chrome-canary</code> 安装,</p>
<a id="more"></a>
<h1 id="book-reading"><a href="#book-reading" class="headerlink" title="book reading"></a>book reading</h1><h2 id="apue-守护进程"><a href="#apue-守护进程" class="headerlink" title="apue 守护进程"></a>apue 守护进程</h2><h3 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h3><p>守护进程没有控制终端, 终端前台进程组ID为 -1</p>
<h3 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h3><ol>
<li>umask 重置文件模式创建屏蔽字</li>
<li>fork 使父进程退出</li>
<li>setsid 开启新会话</li>
<li>更改当前工作目录, 避免文件系统不能被拆卸</li>
<li>关闭不再需要的文件描述符</li>
<li>重定向标准输入/输出/出错</li>
</ol>
<h3 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h3><p>可以使用文件和记录锁, 保证同一时间只有一个进程运行</p>
<h3 id="守护进程惯例"><a href="#守护进程惯例" class="headerlink" title="守护进程惯例"></a>守护进程惯例</h3><ul>
<li>文件锁一般使用 /var/run/name.pid</li>
<li>配置选项一般使用 /etc/name.conf</li>
<li>初始化脚本一般使用 /etc/init.d/<em> 或 /etc/rc</em></li>
<li>一般通过捕捉 SIGHUP 进行配置重载</li>
</ul>
<h1 id="tech-learning"><a href="#tech-learning" class="headerlink" title="tech learning"></a>tech learning</h1><h2 id="golang-reflect"><a href="#golang-reflect" class="headerlink" title="golang reflect"></a>golang reflect</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类型断言</span></div><div class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;</div><div class="line">    Process(v)</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类型判断</span></div><div class="line"><span class="keyword">switch</span> t := areaIntf.(<span class="keyword">type</span>) &#123;</div><div class="line"><span class="keyword">case</span> *Square:</div><div class="line">	fmt.Printf(<span class="string">"Type Square %T with value %v\n"</span>, t, t)</div><div class="line"><span class="keyword">case</span> *Circle:</div><div class="line">	fmt.Printf(<span class="string">"Type Circle %T with value %v\n"</span>, t, t)</div><div class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">	fmt.Printf(<span class="string">"nil value: nothing to check?\n"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	fmt.Printf(<span class="string">"Unexpected type %T\n"</span>, t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="advanced-bash-scripting-guide"><a href="#advanced-bash-scripting-guide" class="headerlink" title="advanced-bash-scripting-guide"></a>advanced-bash-scripting-guide</h2><p>引用变量</p>
<p>单引号代表全引用, 所有的值都用字面意思解释.<br>因此, 试图在单引号中转义单引号是错误的.<br>错误: <code>echo &#39;i\&#39;m something&#39;</code><br>但是可以通过其它的方式解决这个问题.<br>正确: <code>echo &#39;i&#39;\&#39;&#39;m something&#39;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hack-news&quot;&gt;&lt;a href=&quot;#hack-news&quot; class=&quot;headerlink&quot; title=&quot;hack news&quot;&gt;&lt;/a&gt;hack news&lt;/h1&gt;&lt;h2 id=&quot;headless-chrome&quot;&gt;&lt;a href=&quot;#headless-chrome&quot; class=&quot;headerlink&quot; title=&quot;headless chrome&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome&quot; target=&quot;_blank&quot;&gt;headless chrome&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;headless chrome 允许在不启动浏览器窗口的情况下, 测试浏览器的网页加载, 这对自动化测试提供了方便.&lt;/p&gt;
&lt;p&gt;成文时, 稳定版的 chrome 刚刚48版本, 还不支持 headless, 需要安装 chrome canary.&lt;br&gt;mac os 可以使用 &lt;code&gt;brew install Caskroom/versions/google-chrome-canary&lt;/code&gt; 安装,&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-01</title>
    <link href="http://blog.sin5th.com/2017/05/01/2017-05-01/"/>
    <id>http://blog.sin5th.com/2017/05/01/2017-05-01/</id>
    <published>2017-05-01T13:20:47.000Z</published>
    <updated>2017-05-05T15:04:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang-初体验"><a href="#golang-初体验" class="headerlink" title="golang 初体验"></a>golang 初体验</h1><p>最近考虑学习 golang, 跟随 <a href="https://tour.go-zh.org/" target="_blank" rel="external">https://tour.go-zh.org/</a> 把基础语法跑了一遍.</p>
<p>由于之前掌握过 python/lua/js, 对 golang 有着似曾相识的感觉. 闭包/匿名函数/微线程, 都标志这是一门很”现代”的语言.</p>
<p>后继的学习都记录在 <a href="https://github.com/sin5th/go-learning" target="_blank" rel="external">https://github.com/sin5th/go-learning</a></p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;golang-初体验&quot;&gt;&lt;a href=&quot;#golang-初体验&quot; class=&quot;headerlink&quot; title=&quot;golang 初体验&quot;&gt;&lt;/a&gt;golang 初体验&lt;/h1&gt;&lt;p&gt;最近考虑学习 golang, 跟随 &lt;a href=&quot;https://tour.go-zh.org/&quot;&gt;https://tour.go-zh.org/&lt;/a&gt; 把基础语法跑了一遍.&lt;/p&gt;
&lt;p&gt;由于之前掌握过 python/lua/js, 对 golang 有着似曾相识的感觉. 闭包/匿名函数/微线程, 都标志这是一门很”现代”的语言.&lt;/p&gt;
&lt;p&gt;后继的学习都记录在 &lt;a href=&quot;https://github.com/sin5th/go-learning&quot;&gt;https://github.com/sin5th/go-learning&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-27</title>
    <link href="http://blog.sin5th.com/2017/04/27/2017-04-27/"/>
    <id>http://blog.sin5th.com/2017/04/27/2017-04-27/</id>
    <published>2017-04-27T09:47:38.000Z</published>
    <updated>2017-04-28T10:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-apue"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><blockquote>
<p>信号看的有点晕，先概览一遍，第二圈再细读</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程有很多好处：</p>
<ul>
<li>简化异步事件的处理代码。同步编程比异步编程要简单</li>
<li>进程间共享内存和文件描述符比较麻烦</li>
<li>分解任务提高吞吐量</li>
<li>改善交互程序的响应时间</li>
</ul>
<a id="more"></a>
<h3 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h3><p>线程ID只在进程环境中有效，用 pthread_t 表示<br>因为在不同的操作系统中 pthread_t 的实现不同，因此需要专门的比较函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</div></pre></td></tr></table></figure></p>
<p>获取自身的线程ID<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div></pre></td></tr></table></figure></p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">int pthread_create(</div><div class="line">  pthread_t *restrict tidp,</div><div class="line">  const pthread_attr_t *restrict attr,</div><div class="line">  void *(*start_rtn),</div><div class="line">  void *restrict arg</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><ol>
<li>从启动例程中返回，返回值是线程的退出码</li>
<li>被同一进程中的其他线程取消</li>
<li>线程调用 pthread_exit<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>进程中的其他线程可以使用 pthread_join 函数访问到 rval_ptr 这个指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>进程中的其他线程可以使用 pthread_cancel 函数取消同一进程中的其他线程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>互斥量用 pthread_mutex_t 表示，使用之前要调用 pthread_mutex_init 函数进行初始化，也可以赋值为 PTHREAD_MUTEX_INITIALIZER。使用之后要调用 pthread_mutex_destroy 函数进行摧毁，即使是动态申请的也要这样做。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_mutex_t</span> *mutex</div><div class="line">);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果线程对同一互斥量加锁两次，它自身就会陷入死锁状态，使用互斥量时，还有其他更不明显的方式也能产生死锁。</p>
</blockquote>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁也叫共享-独占锁，当读模式锁定时，它是共享模式锁住的，当写模式锁定时，它是独占模式锁住的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</div><div class="line">  <span class="keyword">const</span> pthread_rwlockattr *<span class="keyword">restrict</span> attr</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_rwlock_t</span> *rwlock</div><div class="line">);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</div><div class="line">  <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr</div><div class="line">);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *cond</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</div><div class="line">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex</div><div class="line">);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</div><div class="line">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> timeout</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *cond</div><div class="line">);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *cond</div><div class="line">);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;信号看的有点晕，先概览一遍，第二圈再细读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;线程有很多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化异步事件的处理代码。同步编程比异步编程要简单&lt;/li&gt;
&lt;li&gt;进程间共享内存和文件描述符比较麻烦&lt;/li&gt;
&lt;li&gt;分解任务提高吞吐量&lt;/li&gt;
&lt;li&gt;改善交互程序的响应时间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-24</title>
    <link href="http://blog.sin5th.com/2017/04/24/2017-04-24/"/>
    <id>http://blog.sin5th.com/2017/04/24/2017-04-24/</id>
    <published>2017-04-24T13:51:27.000Z</published>
    <updated>2017-04-24T09:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-apue"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>本章介绍 UNIX 的进程控制，包括创建新进程、执行进程和进程终止</p>
<h3 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h3><p>每个进程都有一个非负数型表示的唯一进程ID</p>
<p>ID为 0 的进程通常是调度进程，常被称为交换进程（swapper）<br>ID为 1 的进程通常是init进程，负责在自举内核后启动一个UNIX系统  </p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);  <span class="comment">// 进程PID</span></div><div class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>); <span class="comment">// 父进程PID</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);  <span class="comment">// 实际用户ID</span></div><div class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>); <span class="comment">// 有效用户ID</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);  <span class="comment">// 实际组ID</span></div><div class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>); <span class="comment">// 有效组ID</span></div></pre></td></tr></table></figure>
<h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork 函数"></a>fork 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>父、子进程只共享正文段。</p>
<blockquote>
<p>由于在 fork 之后经常跟随着 exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全复制。而是使用写时拷贝技术。</p>
</blockquote>
<p>fork 失败的两个主要原因：</p>
<ul>
<li>系统有了太多的进程</li>
<li>用户的进程总数超过了系统限制</li>
</ul>
<p>fork 有下面两种用法：</p>
<ul>
<li>父进程希望复制自己，使父、子进程同时执行不同的代码段</li>
<li>执行一个不同的程序</li>
</ul>
<h3 id="wait-和-waitpid-函数"><a href="#wait-和-waitpid-函数" class="headerlink" title="wait 和 waitpid 函数"></a>wait 和 waitpid 函数</h3><p>调用 wait 或 waitpid 的进程：</p>
<ul>
<li>如果所有子进程都还在运行，则阻塞</li>
<li>如果一个子进程已终止，正等待父进程获取终止状态，则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程，则立即出错返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</div></pre></td></tr></table></figure>
<p>statloc 是存放进程退出状态的整型指针，用下面4个宏判断：</p>
<ul>
<li>WIFEXITED(status)</li>
<li>WIFSIGNALED(status)</li>
<li>WIFSTOPPED(status)</li>
<li>WIFCONTINUED(status)</li>
</ul>
<h3 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec 函数"></a>exec 函数</h3><p>execlp<br>execvp<br>execl<br>execv<br>execle<br>execvp</p>
<h2 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;进程控制&quot;&gt;&lt;a href=&quot;#进程控制&quot; class=&quot;headerlink&quot; title=&quot;进程控制&quot;&gt;&lt;/a&gt;进程控制&lt;/h2&gt;&lt;p&gt;本章介绍 UNIX 的进程控制，包括创建新进程、执行进程和进程终止&lt;/p&gt;
&lt;h3 id=&quot;进程标识符&quot;&gt;&lt;a href=&quot;#进程标识符&quot; class=&quot;headerlink&quot; title=&quot;进程标识符&quot;&gt;&lt;/a&gt;进程标识符&lt;/h3&gt;&lt;p&gt;每个进程都有一个非负数型表示的唯一进程ID&lt;/p&gt;
&lt;p&gt;ID为 0 的进程通常是调度进程，常被称为交换进程（swapper）&lt;br&gt;ID为 1 的进程通常是init进程，负责在自举内核后启动一个UNIX系统  &lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-21</title>
    <link href="http://blog.sin5th.com/2017/04/21/2017-04-21/"/>
    <id>http://blog.sin5th.com/2017/04/21/2017-04-21/</id>
    <published>2017-04-21T07:40:18.000Z</published>
    <updated>2017-04-23T13:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-apue"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><ul>
<li>main 函数是如何被调用</li>
<li>命令行参数如何传送给执行程序</li>
<li>典型的存储器布局是什么样式</li>
<li>如何分配另外的存储空间</li>
<li>如何使用环境变量</li>
<li>不同的进程终止方式</li>
</ul>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p><code>int main(int argc, char *argv[])</code></p>
<p>调用main前先调用一个特殊的启动例程。启动例程先从内核取得命令行参数和环境变量值，为调用main函数做好准备。</p>
<a id="more"></a>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>有8种方式使进程终止，其中5种为正常终止：</p>
<ol>
<li>从 main 返回</li>
<li>调用 exit</li>
<li>调用 _exit 或 _Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用 pthread_exit</li>
<li>调用 abort</li>
<li>接到一个信号并终止</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>exit 函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure></p>
<p>atexit 函数<br>登记 exit 的回调函数。同一函数被登记多次，也会被调用多次。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div></pre></td></tr></table></figure>
<h3 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h3><p>extern char **environ;</p>
<h3 id="c程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h3><p>C程序一直由下面几部分组成：</p>
<ul>
<li>正文段。由 CPU 执行的机器指令部分</li>
<li>初始化数据段。包含了程序中需明确地赋初值的变量</li>
<li>非初始化数据段。通常称bss段（block started by symbol）</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息</li>
<li>堆。动态存储的分配</li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>共享库使得可执行文件中不再需要包含公用的库例程，而只需在所有进程都可引用的存储区中维护这种库例程的一个副本<br>减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时</p>
<h3 id="存储器分配"><a href="#存储器分配" class="headerlink" title="存储器分配"></a>存储器分配</h3><ol>
<li>malloc 分配指定字节数的存储区。存储区中的初始值不确定</li>
<li>calloc 为指定数量具有指定长度的对象分配存储空间。存储区中的每一位都初始化为0</li>
<li>realloc 更改以前分配区的长度（增加或减少）。新增区域的初始值不确定</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>这三个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>putenv 会直接将参数传入环境表。如果这个参数是栈中的字符串，就会发生错误</p>
</blockquote>
<h3 id="setjump-和-longjump"><a href="#setjump-和-longjump" class="headerlink" title="setjump 和 longjump"></a>setjump 和 longjump</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjump</span><span class="params">(jmp_buf env,<span class="keyword">int</span> val)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="getrlimit-和-setrlimit"><a href="#getrlimit-和-setrlimit" class="headerlink" title="getrlimit 和 setrlimit"></a>getrlimit 和 setrlimit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div></pre></td></tr></table></figure>
<p>更改资源限制，遵循下列三条规则：</p>
<ul>
<li>任何一个进程都可以将其软限制值更改为小于或等于其硬限制值</li>
<li>任何一个进程都可降低其硬件限制值，但它必须大于或等于其软限制值</li>
<li>只有超级客户可以提高硬限制值</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;进程环境&quot;&gt;&lt;a href=&quot;#进程环境&quot; class=&quot;headerlink&quot; title=&quot;进程环境&quot;&gt;&lt;/a&gt;进程环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;main 函数是如何被调用&lt;/li&gt;
&lt;li&gt;命令行参数如何传送给执行程序&lt;/li&gt;
&lt;li&gt;典型的存储器布局是什么样式&lt;/li&gt;
&lt;li&gt;如何分配另外的存储空间&lt;/li&gt;
&lt;li&gt;如何使用环境变量&lt;/li&gt;
&lt;li&gt;不同的进程终止方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用main前先调用一个特殊的启动例程。启动例程先从内核取得命令行参数和环境变量值，为调用main函数做好准备。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-20</title>
    <link href="http://blog.sin5th.com/2017/04/20/2017-04-20/"/>
    <id>http://blog.sin5th.com/2017/04/20/2017-04-20/</id>
    <published>2017-04-20T01:56:25.000Z</published>
    <updated>2017-04-21T05:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-apue"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="标准io库"><a href="#标准I-O库" class="headerlink" title="标准I/O库"></a>标准I/O库</h2><h3 id="流和file对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h3><h4 id="流的定向"><a href="#流的定向" class="headerlink" title="流的定向"></a>流的定向</h4><p>流可用于单字节或多字节字符集<br>未定项的流，一旦使用多字节就定向为多字节流，一旦使用单字节就定向为单字节流<br><code>freopen</code>和<code>fwide</code>可以改变留的定向<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div></pre></td></tr></table></figure></p>
<p>mode &lt; 0，设置为单字节——字节定向<br>mode &gt; 0，设置为多字节——宽定向<br>mode = 0，查询当前定向  </p>
<blockquote>
<p>注： fwide 只能用来设置未定向的流  </p>
</blockquote>
<a id="more"></a>
<h3 id="标准输入-标准输出和标准出错"><a href="#标准输入、标准输出和标准出错" class="headerlink" title="标准输入、标准输出和标准出错"></a>标准输入、标准输出和标准出错</h3><p>stdin，stdout，stderr 定义在 <stdio.h></stdio.h></p>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。</p>
<h4 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h4><ol>
<li>全缓冲</li>
<li>行缓冲</li>
<li>不带缓冲<br>ISO C 要求下列缓冲特征：</li>
</ol>
<ul>
<li>当且仅当标准输入和标准输出不涉及交互式设备时，才是全缓冲的</li>
<li>标准出错绝不会是全缓冲的</li>
</ul>
<h4 id="改变缓冲类型"><a href="#改变缓冲类型" class="headerlink" title="改变缓冲类型"></a>改变缓冲类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>setvbuf 可以精确控制缓冲类型：  </p>
<ul>
<li>_IOFBF 全缓冲  </li>
<li>_IOLBF 行缓冲  </li>
<li>_IONBF 不带缓冲  </li>
</ul>
<p>强制刷新流<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果 fp 是 NULL，将导致所有输出流被冲洗</p>
</blockquote>
<h3 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">fdoen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div></pre></td></tr></table></figure>
<ol>
<li>fopen 打开指定文件</li>
<li>freopen 打开指定文件，并关联到某个流上</li>
<li>fdopen 将一个标准I/O流与一个文件描述符相结合</li>
</ol>
<blockquote>
<p>fdopen 函数常用语由创建管道和网络通信通道函数返回的描述符</p>
</blockquote>
<p>当以读和写类型打开一文件时，有下列限制：</p>
<ul>
<li>如果没有fflush、fseek、fsetpos 或 rewind，则输出之后不能直接输入</li>
<li>如果没有fseek、fsetpos、rewind，或输入未到文件尾，则输入操作之后不能直接输出</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">限制</th>
<th style="text-align:center">r</th>
<th style="text-align:center">w</th>
<th style="text-align:center">a</th>
<th style="text-align:center">r+</th>
<th style="text-align:center">w+</th>
<th style="text-align:center">a+</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件必须已存在</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">擦除文件以前的内容</td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">流可以读</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">流可以写</td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">流只可在尾端处写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
</tr>
</tbody>
</table>
<h3 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h3><ol>
<li>每次一个字符的I/O</li>
<li>每次一行的I/O</li>
<li>直接I/O</li>
</ol>
<h4 id="一次一个字符"><a href="#一次一个字符" class="headerlink" title="一次一个字符"></a>一次一个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>getchar 等价与 getc(stdin);<br>getc 可被实现为宏，而 fgetc 则不能。这意味着：  </p>
<ol>
<li>getc 的参数不应当是具有副作用的表达式</li>
<li>fgetc 一定是函数，可以得到其地址</li>
<li>fgetc 调用时间比 getc 长</li>
</ol>
</blockquote>
<p>区分出错还是文件结尾<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>将读出的字符压送回流中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>有以下几个输出函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="一次一行"><a href="#一次一行" class="headerlink" title="一次一行"></a>一次一行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="二进制io"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h3><p>解决读、写整个结构的问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div></pre></td></tr></table></figure>
<p>二进制I/O在单独机器上运行没什么问题，但在多台机器协作的情况下，可能因为编译器、系统有异，整型、浮点型格式不同等原因遇到问题。<br>面对这种问题的实际解决办法是使用较高级的协议。</p>
<h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><p>三种方法定位标准I/O流  </p>
<ol>
<li>ftell 和 fseek</li>
<li>ftello 和 fseeko</li>
<li>fgetpos 和 fsetpos<blockquote>
<p>注：需要移植到非unix系统上运行的应用程序应当使用 fgetpos 和 fsetpos</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">off_t</span> ftello(FILE *fp);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="格式化io"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h3><p>格式化输出<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n, constr <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>%[flags][fldwidth][precision][lenmodifier]convtype</p>
<p>flags 的可用值</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>在字段内左对齐输出</td>
</tr>
<tr>
<td>+</td>
<td>总是显示带符号转换的符号</td>
</tr>
<tr>
<td>（空格）</td>
<td>如果第一个字符不是符号，则在前面加上一个空格</td>
</tr>
<tr>
<td>#</td>
<td>指定另一种转换形式（例如，对于十六进制格式，加0x前缀）</td>
</tr>
<tr>
<td>0</td>
<td>添加前导0（而非空格）进行填充</td>
</tr>
</tbody>
</table>
<p>printf 族的变体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>格式化输入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>%[*][fldwidth][lenmodifier]convtype</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;标准I-O库&quot;&gt;&lt;a href=&quot;#标准I-O库&quot; class=&quot;headerlink&quot; title=&quot;标准I/O库&quot;&gt;&lt;/a&gt;标准I/O库&lt;/h2&gt;&lt;h3 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink&quot; title=&quot;流和FILE对象&quot;&gt;&lt;/a&gt;流和FILE对象&lt;/h3&gt;&lt;h4 id=&quot;流的定向&quot;&gt;&lt;a href=&quot;#流的定向&quot; class=&quot;headerlink&quot; title=&quot;流的定向&quot;&gt;&lt;/a&gt;流的定向&lt;/h4&gt;&lt;p&gt;流可用于单字节或多字节字符集&lt;br&gt;未定项的流，一旦使用多字节就定向为多字节流，一旦使用单字节就定向为单字节流&lt;br&gt;&lt;code&gt;freopen&lt;/code&gt;和&lt;code&gt;fwide&lt;/code&gt;可以改变留的定向&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;wchar.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fwide&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FILE *fp, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;mode &amp;lt; 0，设置为单字节——字节定向&lt;br&gt;mode &amp;gt; 0，设置为多字节——宽定向&lt;br&gt;mode = 0，查询当前定向  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注： fwide 只能用来设置未定向的流  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-19</title>
    <link href="http://blog.sin5th.com/2017/04/19/2017-04-19/"/>
    <id>http://blog.sin5th.com/2017/04/19/2017-04-19/</id>
    <published>2017-04-19T03:37:25.000Z</published>
    <updated>2017-04-20T13:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-apue"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="posix"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>可移植的操作系统接口<br>定义的接口而非实现，因此不区分 <em>系统调用</em> 和 <em>库函数</em></p>
<h2 id="文件-io"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h2><h3 id="进程访问文件时的层次结构"><a href="#进程访问文件时的层次结构" class="headerlink" title="进程访问文件时的层次结构"></a>进程访问文件时的层次结构</h3><ul>
<li>进程表（描述符+文件指针）</li>
<li>文件表（状态标记+当前偏移量+v节点指针）</li>
<li>v节点表（v节点信息+i节点信息+文件长度）</li>
</ul>
<a id="more"></a>
<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><blockquote>
<p>改变已打开文件的性质<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>它有5种功能：</p>
<ol>
<li>复制一个现有的描述符（cmd = F_DUPFD）</li>
<li>获得/设置文件描述符标记（cmd = F_GETFD/F_SETFD）</li>
<li>获得/设置文件状态标记（cmd = F_GETFL/F_SETFL）</li>
<li>获得/设置异步I/O所有权（cmd = F_GETOWN/F_SETOWN）</li>
<li>获得/设置记录锁（cmd = F_GETLK/F_SETLK/F_SETLKW）</li>
</ol>
<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><blockquote>
<p>I/O 操作的杂物箱<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    /* System V */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; /* BSD and Linux */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;   /* XSI STREAMS */</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> request, ...)</span></span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>上述是 ioctl 函数本身所要求的头文件。通常，还要求另外的设备专用头文件，这些头文件中可能会定义一组专用的命令。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="stat-fstat-lstat"><a href="#stat、fstat、lstat" class="headerlink" title="stat、fstat、lstat"></a>stat、fstat、lstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div></pre></td></tr></table></figure>
<p>stat 函数返回与明明文件有关的信息结构。<br>fstat 函数获取已在描述符 filedes 上打开文件的有关信息。<br>lstat 函数类似于 stat，但是当命名的文件是一个符号链接时，lstat 返回符号链接的有关信息。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>包含在 stat 结构的 st_mode 成员中，使用以下宏确定文件类型</p>
<ol>
<li>普通文件 S_ISREG</li>
<li>目录文件 S_ISDIR</li>
<li>块特殊文件 S_ISCHR</li>
<li>字符特殊文件 S_ISBLK</li>
<li>FIFO S_ISFIFO</li>
<li>套接字 S_ISSOCK</li>
<li>符号链接 S_ISLNK</li>
</ol>
<h3 id="确定-ipc-对象的类型的宏"><a href="#确定-IPC-对象的类型的宏" class="headerlink" title="确定 IPC 对象的类型的宏"></a>确定 IPC 对象的类型的宏</h3><ol>
<li>消息队列 S_TYPEISMQ</li>
<li>信号量 S_TYPEISSEM</li>
<li>共享存储对象 S_TYPEISSHM</li>
</ol>
<h3 id="用户id和组id"><a href="#用户ID和组ID" class="headerlink" title="用户ID和组ID"></a>用户ID和组ID</h3><ul>
<li>实际用户ID和组ID<ul>
<li>标识我们究竟是谁</li>
</ul>
</li>
<li>有效用户ID和组ID以及附加组ID<ul>
<li>决定我们的访问权限</li>
</ul>
</li>
<li>保存的设置用户ID和组ID<ul>
<li>执行程序时，对<strong>有效用户ID和组ID</strong>保存的副本</li>
</ul>
</li>
</ul>
<h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><table>
<thead>
<tr>
<th>st_mode 屏蔽</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>用户-读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户-写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户-执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组-读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组-写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组-执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他-读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他-写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他-执行</td>
</tr>
</tbody>
</table>
<p>进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试。所有者ID是文件的性质，有效ID和附加组ID是进程的性质。内核的测试是：</p>
<ol>
<li>若进程的有效用户ID是0，则允许访问</li>
<li>若进程的有效用户ID等于文件的所有者ID，则应用相应规则</li>
<li>若进程的有效小组ID或附加组ID之一等于文件的组ID，则应用相应规则</li>
<li>应用其他用户的规则</li>
</ol>
<p><code>access</code> 按实际用户ID和zuID进行访问权限检测</p>
<p>设置<strong>用户ID位</strong>，或<strong>组ID位</strong>。一般用来对执行二进制的进程进行提权，比如 passwd</p>
<p>设置<strong>粘住位</strong>的目录，对该目录有写权限的用户在满足下列条件之一的情况下，才能删除或更名该目录下的文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<h3 id="link-unlink-remove-和-rename"><a href="#link、unlink、remove-和-rename" class="headerlink" title="link、unlink、remove 和 rename"></a>link、unlink、remove 和 rename</h3><p>unlink 常被用来确保即使程序崩溃，它所创建的临时文件也不会留下来</p>
<h3 id="symlink-和-readlink"><a href="#symlink-和-readlink" class="headerlink" title="symlink 和 readlink"></a>symlink 和 readlink</h3><p>symlink 创建一个符号链接<br>readlink 打开链接本身（相反，open 跟随符号链接）  </p>
<h3 id="utime"><a href="#utime" class="headerlink" title="utime"></a>utime</h3><p>utime 修改文件的<strong>访问</strong>和<strong>修改</strong>时间</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;POSIX&quot;&gt;&lt;a href=&quot;#POSIX&quot; class=&quot;headerlink&quot; title=&quot;POSIX&quot;&gt;&lt;/a&gt;POSIX&lt;/h2&gt;&lt;p&gt;可移植的操作系统接口&lt;br&gt;定义的接口而非实现，因此不区分 &lt;em&gt;系统调用&lt;/em&gt; 和 &lt;em&gt;库函数&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;文件-I-O&quot;&gt;&lt;a href=&quot;#文件-I-O&quot; class=&quot;headerlink&quot; title=&quot;文件 I/O&quot;&gt;&lt;/a&gt;文件 I/O&lt;/h2&gt;&lt;h3 id=&quot;进程访问文件时的层次结构&quot;&gt;&lt;a href=&quot;#进程访问文件时的层次结构&quot; class=&quot;headerlink&quot; title=&quot;进程访问文件时的层次结构&quot;&gt;&lt;/a&gt;进程访问文件时的层次结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程表（描述符+文件指针）&lt;/li&gt;
&lt;li&gt;文件表（状态标记+当前偏移量+v节点指针）&lt;/li&gt;
&lt;li&gt;v节点表（v节点信息+i节点信息+文件长度）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
</feed>
