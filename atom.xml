<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sin5&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sin5th.com/"/>
  <updated>2017-05-03T01:57:43.000Z</updated>
  <id>http://blog.sin5th.com/</id>
  
  <author>
    <name>sin5</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017-05-02</title>
    <link href="http://blog.sin5th.com/2017/05/02/2017-05-02/"/>
    <id>http://blog.sin5th.com/2017/05/02/2017-05-02/</id>
    <published>2017-05-02T01:52:18.000Z</published>
    <updated>2017-05-03T01:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hack-news"><a href="#hack-news" class="headerlink" title="hack news"></a>hack news</h1><h2 id="headless-chrome"><a href="#headless-chrome" class="headerlink" title="headless chrome"></a><a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank">headless chrome</a></h2><p>headless chrome 允许在不启动浏览器窗口的情况下, 测试浏览器的网页加载, 这对自动化测试提供了方便.</p>
<p>成文时, 稳定版的 chrome 刚刚48版本, 还不支持 headless, 需要安装 chrome canary.<br>mac os 可以使用 <code>brew install Caskroom/versions/google-chrome-canary</code> 安装,</p>
<a id="more"></a>
<h1 id="book-reading"><a href="#book-reading" class="headerlink" title="book reading"></a>book reading</h1><h2 id="apue-守护进程"><a href="#apue-守护进程" class="headerlink" title="apue 守护进程"></a>apue 守护进程</h2><h3 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h3><p>守护进程没有控制终端, 终端前台进程组ID为 -1</p>
<h3 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h3><ol>
<li>umask 重置文件模式创建屏蔽字</li>
<li>fork 使父进程退出</li>
<li>setsid 开启新会话</li>
<li>更改当前工作目录, 避免文件系统不能被拆卸</li>
<li>关闭不再需要的文件描述符</li>
<li>重定向标准输入/输出/出错</li>
</ol>
<h3 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h3><p>可以使用文件和记录锁, 保证同一时间只有一个进程运行</p>
<h3 id="守护进程惯例"><a href="#守护进程惯例" class="headerlink" title="守护进程惯例"></a>守护进程惯例</h3><ul>
<li>文件锁一般使用 /var/run/name.pid</li>
<li>配置选项一般使用 /etc/name.conf</li>
<li>初始化脚本一般使用 /etc/init.d/<em> 或 /etc/rc</em></li>
<li>一般通过捕捉 SIGHUP 进行配置重载</li>
</ul>
<h1 id="tech-learning"><a href="#tech-learning" class="headerlink" title="tech learning"></a>tech learning</h1><h2 id="golang-reflect"><a href="#golang-reflect" class="headerlink" title="golang reflect"></a>golang reflect</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类型断言</span></div><div class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;</div><div class="line">    Process(v)</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类型判断</span></div><div class="line"><span class="keyword">switch</span> t := areaIntf.(<span class="keyword">type</span>) &#123;</div><div class="line"><span class="keyword">case</span> *Square:</div><div class="line">	fmt.Printf(<span class="string">"Type Square %T with value %v\n"</span>, t, t)</div><div class="line"><span class="keyword">case</span> *Circle:</div><div class="line">	fmt.Printf(<span class="string">"Type Circle %T with value %v\n"</span>, t, t)</div><div class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">	fmt.Printf(<span class="string">"nil value: nothing to check?\n"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	fmt.Printf(<span class="string">"Unexpected type %T\n"</span>, t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="advanced-bash-scripting-guide"><a href="#advanced-bash-scripting-guide" class="headerlink" title="advanced-bash-scripting-guide"></a>advanced-bash-scripting-guide</h2><p>引用变量</p>
<p>单引号代表全引用, 所有的值都用字面意思解释.<br>因此, 试图在单引号中转义单引号是错误的.<br>错误: <code>echo &#39;i\&#39;m something&#39;</code><br>但是可以通过其它的方式解决这个问题.<br>正确: <code>echo &#39;i&#39;\&#39;&#39;m something&#39;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hack-news&quot;&gt;&lt;a href=&quot;#hack-news&quot; class=&quot;headerlink&quot; title=&quot;hack news&quot;&gt;&lt;/a&gt;hack news&lt;/h1&gt;&lt;h2 id=&quot;headless-chrome&quot;&gt;&lt;a href=&quot;#headless-chrome&quot; class=&quot;headerlink&quot; title=&quot;headless chrome&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome&quot; target=&quot;_blank&quot;&gt;headless chrome&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;headless chrome 允许在不启动浏览器窗口的情况下, 测试浏览器的网页加载, 这对自动化测试提供了方便.&lt;/p&gt;
&lt;p&gt;成文时, 稳定版的 chrome 刚刚48版本, 还不支持 headless, 需要安装 chrome canary.&lt;br&gt;mac os 可以使用 &lt;code&gt;brew install Caskroom/versions/google-chrome-canary&lt;/code&gt; 安装,&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-05-01</title>
    <link href="http://blog.sin5th.com/2017/05/01/2017-05-01/"/>
    <id>http://blog.sin5th.com/2017/05/01/2017-05-01/</id>
    <published>2017-05-01T13:20:47.000Z</published>
    <updated>2017-05-01T13:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang-初体验"><a href="#golang-初体验" class="headerlink" title="golang 初体验"></a>golang 初体验</h1><p>最近考虑学习 golang, 跟随 <a href="https://tour.go-zh.org/" target="_blank" rel="external">https://tour.go-zh.org/</a> 把基础语法跑了一遍.</p>
<p>由于之前掌握过 python/lua/js, 对 golang 有着似曾相识的感觉. 闭包/匿名函数/微线程, 都标志这是一门很”现代”的语言.</p>
<p>后继的学习都记录在 <a href="https://github.com/sin5/go-learning" target="_blank" rel="external">https://github.com/sin5/go-learning</a></p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;golang-初体验&quot;&gt;&lt;a href=&quot;#golang-初体验&quot; class=&quot;headerlink&quot; title=&quot;golang 初体验&quot;&gt;&lt;/a&gt;golang 初体验&lt;/h1&gt;&lt;p&gt;最近考虑学习 golang, 跟随 &lt;a href=&quot;https://tour.go-zh.org/&quot;&gt;https://tour.go-zh.org/&lt;/a&gt; 把基础语法跑了一遍.&lt;/p&gt;
&lt;p&gt;由于之前掌握过 python/lua/js, 对 golang 有着似曾相识的感觉. 闭包/匿名函数/微线程, 都标志这是一门很”现代”的语言.&lt;/p&gt;
&lt;p&gt;后继的学习都记录在 &lt;a href=&quot;https://github.com/sin5/go-learning&quot;&gt;https://github.com/sin5/go-learning&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-27</title>
    <link href="http://blog.sin5th.com/2017/04/27/2017-04-27/"/>
    <id>http://blog.sin5th.com/2017/04/27/2017-04-27/</id>
    <published>2017-04-27T09:47:38.000Z</published>
    <updated>2017-04-28T10:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-APUE"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><blockquote>
<p>信号看的有点晕，先概览一遍，第二圈再细读</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程有很多好处：</p>
<ul>
<li>简化异步事件的处理代码。同步编程比异步编程要简单</li>
<li>进程间共享内存和文件描述符比较麻烦</li>
<li>分解任务提高吞吐量</li>
<li>改善交互程序的响应时间</li>
</ul>
<a id="more"></a>
<h3 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h3><p>线程ID只在进程环境中有效，用 pthread_t 表示<br>因为在不同的操作系统中 pthread_t 的实现不同，因此需要专门的比较函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</div></pre></td></tr></table></figure></p>
<p>获取自身的线程ID<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div></pre></td></tr></table></figure></p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">int pthread_create(</div><div class="line">  pthread_t *restrict tidp,</div><div class="line">  const pthread_attr_t *restrict attr,</div><div class="line">  void *(*start_rtn),</div><div class="line">  void *restrict arg</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><ol>
<li>从启动例程中返回，返回值是线程的退出码</li>
<li>被同一进程中的其他线程取消</li>
<li>线程调用 pthread_exit<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>进程中的其他线程可以使用 pthread_join 函数访问到 rval_ptr 这个指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>进程中的其他线程可以使用 pthread_cancel 函数取消同一进程中的其他线程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>互斥量用 pthread_mutex_t 表示，使用之前要调用 pthread_mutex_init 函数进行初始化，也可以赋值为 PTHREAD_MUTEX_INITIALIZER。使用之后要调用 pthread_mutex_destroy 函数进行摧毁，即使是动态申请的也要这样做。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_mutex_t</span> *mutex</div><div class="line">);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果线程对同一互斥量加锁两次，它自身就会陷入死锁状态，使用互斥量时，还有其他更不明显的方式也能产生死锁。</p>
</blockquote>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁也叫共享-独占锁，当读模式锁定时，它是共享模式锁住的，当写模式锁定时，它是独占模式锁住的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</div><div class="line">  <span class="keyword">const</span> pthread_rwlockattr *<span class="keyword">restrict</span> attr</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_rwlock_t</span> *rwlock</div><div class="line">);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</div><div class="line">  <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr</div><div class="line">);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *cond</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</div><div class="line">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex</div><div class="line">);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</div><div class="line">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> timeout</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *cond</div><div class="line">);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(</span></span></div><div class="line">  <span class="keyword">pthread_cond_t</span> *cond</div><div class="line">);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;信号看的有点晕，先概览一遍，第二圈再细读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;线程有很多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化异步事件的处理代码。同步编程比异步编程要简单&lt;/li&gt;
&lt;li&gt;进程间共享内存和文件描述符比较麻烦&lt;/li&gt;
&lt;li&gt;分解任务提高吞吐量&lt;/li&gt;
&lt;li&gt;改善交互程序的响应时间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-24</title>
    <link href="http://blog.sin5th.com/2017/04/24/2017-04-24/"/>
    <id>http://blog.sin5th.com/2017/04/24/2017-04-24/</id>
    <published>2017-04-24T13:51:27.000Z</published>
    <updated>2017-04-24T09:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-APUE"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>本章介绍 UNIX 的进程控制，包括创建新进程、执行进程和进程终止</p>
<h3 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h3><p>每个进程都有一个非负数型表示的唯一进程ID</p>
<p>ID为 0 的进程通常是调度进程，常被称为交换进程（swapper）<br>ID为 1 的进程通常是init进程，负责在自举内核后启动一个UNIX系统  </p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);  <span class="comment">// 进程PID</span></div><div class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>); <span class="comment">// 父进程PID</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);  <span class="comment">// 实际用户ID</span></div><div class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>); <span class="comment">// 有效用户ID</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);  <span class="comment">// 实际组ID</span></div><div class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>); <span class="comment">// 有效组ID</span></div></pre></td></tr></table></figure>
<h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork 函数"></a>fork 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>父、子进程只共享正文段。</p>
<blockquote>
<p>由于在 fork 之后经常跟随着 exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全复制。而是使用写时拷贝技术。</p>
</blockquote>
<p>fork 失败的两个主要原因：</p>
<ul>
<li>系统有了太多的进程</li>
<li>用户的进程总数超过了系统限制</li>
</ul>
<p>fork 有下面两种用法：</p>
<ul>
<li>父进程希望复制自己，使父、子进程同时执行不同的代码段</li>
<li>执行一个不同的程序</li>
</ul>
<h3 id="wait-和-waitpid-函数"><a href="#wait-和-waitpid-函数" class="headerlink" title="wait 和 waitpid 函数"></a>wait 和 waitpid 函数</h3><p>调用 wait 或 waitpid 的进程：</p>
<ul>
<li>如果所有子进程都还在运行，则阻塞</li>
<li>如果一个子进程已终止，正等待父进程获取终止状态，则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程，则立即出错返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</div></pre></td></tr></table></figure>
<p>statloc 是存放进程退出状态的整型指针，用下面4个宏判断：</p>
<ul>
<li>WIFEXITED(status)</li>
<li>WIFSIGNALED(status)</li>
<li>WIFSTOPPED(status)</li>
<li>WIFCONTINUED(status)</li>
</ul>
<h3 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec 函数"></a>exec 函数</h3><p>execlp<br>execvp<br>execl<br>execv<br>execle<br>execvp</p>
<h2 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;进程控制&quot;&gt;&lt;a href=&quot;#进程控制&quot; class=&quot;headerlink&quot; title=&quot;进程控制&quot;&gt;&lt;/a&gt;进程控制&lt;/h2&gt;&lt;p&gt;本章介绍 UNIX 的进程控制，包括创建新进程、执行进程和进程终止&lt;/p&gt;
&lt;h3 id=&quot;进程标识符&quot;&gt;&lt;a href=&quot;#进程标识符&quot; class=&quot;headerlink&quot; title=&quot;进程标识符&quot;&gt;&lt;/a&gt;进程标识符&lt;/h3&gt;&lt;p&gt;每个进程都有一个非负数型表示的唯一进程ID&lt;/p&gt;
&lt;p&gt;ID为 0 的进程通常是调度进程，常被称为交换进程（swapper）&lt;br&gt;ID为 1 的进程通常是init进程，负责在自举内核后启动一个UNIX系统  &lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-21</title>
    <link href="http://blog.sin5th.com/2017/04/21/2017-04-21/"/>
    <id>http://blog.sin5th.com/2017/04/21/2017-04-21/</id>
    <published>2017-04-21T07:40:18.000Z</published>
    <updated>2017-04-23T13:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-APUE"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><ul>
<li>main 函数是如何被调用</li>
<li>命令行参数如何传送给执行程序</li>
<li>典型的存储器布局是什么样式</li>
<li>如何分配另外的存储空间</li>
<li>如何使用环境变量</li>
<li>不同的进程终止方式</li>
</ul>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p><code>int main(int argc, char *argv[])</code></p>
<p>调用main前先调用一个特殊的启动例程。启动例程先从内核取得命令行参数和环境变量值，为调用main函数做好准备。</p>
<a id="more"></a>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>有8种方式使进程终止，其中5种为正常终止：</p>
<ol>
<li>从 main 返回</li>
<li>调用 exit</li>
<li>调用 _exit 或 _Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用 pthread_exit</li>
<li>调用 abort</li>
<li>接到一个信号并终止</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>exit 函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure></p>
<p>atexit 函数<br>登记 exit 的回调函数。同一函数被登记多次，也会被调用多次。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div></pre></td></tr></table></figure>
<h3 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h3><p>extern char **environ;</p>
<h3 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h3><p>C程序一直由下面几部分组成：</p>
<ul>
<li>正文段。由 CPU 执行的机器指令部分</li>
<li>初始化数据段。包含了程序中需明确地赋初值的变量</li>
<li>非初始化数据段。通常称bss段（block started by symbol）</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息</li>
<li>堆。动态存储的分配</li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>共享库使得可执行文件中不再需要包含公用的库例程，而只需在所有进程都可引用的存储区中维护这种库例程的一个副本<br>减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时</p>
<h3 id="存储器分配"><a href="#存储器分配" class="headerlink" title="存储器分配"></a>存储器分配</h3><ol>
<li>malloc 分配指定字节数的存储区。存储区中的初始值不确定</li>
<li>calloc 为指定数量具有指定长度的对象分配存储空间。存储区中的每一位都初始化为0</li>
<li>realloc 更改以前分配区的长度（增加或减少）。新增区域的初始值不确定</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>这三个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>putenv 会直接将参数传入环境表。如果这个参数是栈中的字符串，就会发生错误</p>
</blockquote>
<h3 id="setjump-和-longjump"><a href="#setjump-和-longjump" class="headerlink" title="setjump 和 longjump"></a>setjump 和 longjump</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjump</span><span class="params">(jmp_buf env,<span class="keyword">int</span> val)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="getrlimit-和-setrlimit"><a href="#getrlimit-和-setrlimit" class="headerlink" title="getrlimit 和 setrlimit"></a>getrlimit 和 setrlimit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div></pre></td></tr></table></figure>
<p>更改资源限制，遵循下列三条规则：</p>
<ul>
<li>任何一个进程都可以将其软限制值更改为小于或等于其硬限制值</li>
<li>任何一个进程都可降低其硬件限制值，但它必须大于或等于其软限制值</li>
<li>只有超级客户可以提高硬限制值</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;进程环境&quot;&gt;&lt;a href=&quot;#进程环境&quot; class=&quot;headerlink&quot; title=&quot;进程环境&quot;&gt;&lt;/a&gt;进程环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;main 函数是如何被调用&lt;/li&gt;
&lt;li&gt;命令行参数如何传送给执行程序&lt;/li&gt;
&lt;li&gt;典型的存储器布局是什么样式&lt;/li&gt;
&lt;li&gt;如何分配另外的存储空间&lt;/li&gt;
&lt;li&gt;如何使用环境变量&lt;/li&gt;
&lt;li&gt;不同的进程终止方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用main前先调用一个特殊的启动例程。启动例程先从内核取得命令行参数和环境变量值，为调用main函数做好准备。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-20</title>
    <link href="http://blog.sin5th.com/2017/04/20/2017-04-20/"/>
    <id>http://blog.sin5th.com/2017/04/20/2017-04-20/</id>
    <published>2017-04-20T01:56:25.000Z</published>
    <updated>2017-04-21T05:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-APUE"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="标准I-O库"><a href="#标准I-O库" class="headerlink" title="标准I/O库"></a>标准I/O库</h2><h3 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h3><h4 id="流的定向"><a href="#流的定向" class="headerlink" title="流的定向"></a>流的定向</h4><p>流可用于单字节或多字节字符集<br>未定项的流，一旦使用多字节就定向为多字节流，一旦使用单字节就定向为单字节流<br><code>freopen</code>和<code>fwide</code>可以改变留的定向<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div></pre></td></tr></table></figure></p>
<p>mode &lt; 0，设置为单字节——字节定向<br>mode &gt; 0，设置为多字节——宽定向<br>mode = 0，查询当前定向  </p>
<blockquote>
<p>注： fwide 只能用来设置未定向的流  </p>
</blockquote>
<a id="more"></a>
<h3 id="标准输入、标准输出和标准出错"><a href="#标准输入、标准输出和标准出错" class="headerlink" title="标准输入、标准输出和标准出错"></a>标准输入、标准输出和标准出错</h3><p>stdin，stdout，stderr 定义在 <stdio.h></stdio.h></p>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。</p>
<h4 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h4><ol>
<li>全缓冲</li>
<li>行缓冲</li>
<li>不带缓冲<br>ISO C 要求下列缓冲特征：</li>
</ol>
<ul>
<li>当且仅当标准输入和标准输出不涉及交互式设备时，才是全缓冲的</li>
<li>标准出错绝不会是全缓冲的</li>
</ul>
<h4 id="改变缓冲类型"><a href="#改变缓冲类型" class="headerlink" title="改变缓冲类型"></a>改变缓冲类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>setvbuf 可以精确控制缓冲类型：  </p>
<ul>
<li>_IOFBF 全缓冲  </li>
<li>_IOLBF 行缓冲  </li>
<li>_IONBF 不带缓冲  </li>
</ul>
<p>强制刷新流<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果 fp 是 NULL，将导致所有输出流被冲洗</p>
</blockquote>
<h3 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">fdoen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div></pre></td></tr></table></figure>
<ol>
<li>fopen 打开指定文件</li>
<li>freopen 打开指定文件，并关联到某个流上</li>
<li>fdopen 将一个标准I/O流与一个文件描述符相结合</li>
</ol>
<blockquote>
<p>fdopen 函数常用语由创建管道和网络通信通道函数返回的描述符</p>
</blockquote>
<p>当以读和写类型打开一文件时，有下列限制：</p>
<ul>
<li>如果没有fflush、fseek、fsetpos 或 rewind，则输出之后不能直接输入</li>
<li>如果没有fseek、fsetpos、rewind，或输入未到文件尾，则输入操作之后不能直接输出</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">限制</th>
<th style="text-align:center">r</th>
<th style="text-align:center">w</th>
<th style="text-align:center">a</th>
<th style="text-align:center">r+</th>
<th style="text-align:center">w+</th>
<th style="text-align:center">a+</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件必须已存在</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">擦除文件以前的内容</td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">流可以读</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">流可以写</td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">流只可在尾端处写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
</tr>
</tbody>
</table>
<h3 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h3><ol>
<li>每次一个字符的I/O</li>
<li>每次一行的I/O</li>
<li>直接I/O</li>
</ol>
<h4 id="一次一个字符"><a href="#一次一个字符" class="headerlink" title="一次一个字符"></a>一次一个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>getchar 等价与 getc(stdin);<br>getc 可被实现为宏，而 fgetc 则不能。这意味着：  </p>
<ol>
<li>getc 的参数不应当是具有副作用的表达式</li>
<li>fgetc 一定是函数，可以得到其地址</li>
<li>fgetc 调用时间比 getc 长</li>
</ol>
</blockquote>
<p>区分出错还是文件结尾<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>将读出的字符压送回流中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>有以下几个输出函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="一次一行"><a href="#一次一行" class="headerlink" title="一次一行"></a>一次一行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h3><p>解决读、写整个结构的问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div></pre></td></tr></table></figure>
<p>二进制I/O在单独机器上运行没什么问题，但在多台机器协作的情况下，可能因为编译器、系统有异，整型、浮点型格式不同等原因遇到问题。<br>面对这种问题的实际解决办法是使用较高级的协议。</p>
<h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><p>三种方法定位标准I/O流  </p>
<ol>
<li>ftell 和 fseek</li>
<li>ftello 和 fseeko</li>
<li>fgetpos 和 fsetpos<blockquote>
<p>注：需要移植到非unix系统上运行的应用程序应当使用 fgetpos 和 fsetpos</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">off_t</span> ftello(FILE *fp);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h3><p>格式化输出<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n, constr <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>%[flags][fldwidth][precision][lenmodifier]convtype</p>
<p>flags 的可用值</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>在字段内左对齐输出</td>
</tr>
<tr>
<td>+</td>
<td>总是显示带符号转换的符号</td>
</tr>
<tr>
<td>（空格）</td>
<td>如果第一个字符不是符号，则在前面加上一个空格</td>
</tr>
<tr>
<td>#</td>
<td>指定另一种转换形式（例如，对于十六进制格式，加0x前缀）</td>
</tr>
<tr>
<td>0</td>
<td>添加前导0（而非空格）进行填充</td>
</tr>
</tbody>
</table>
<p>printf 族的变体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>格式化输入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>%[*][fldwidth][lenmodifier]convtype</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;标准I-O库&quot;&gt;&lt;a href=&quot;#标准I-O库&quot; class=&quot;headerlink&quot; title=&quot;标准I/O库&quot;&gt;&lt;/a&gt;标准I/O库&lt;/h2&gt;&lt;h3 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink&quot; title=&quot;流和FILE对象&quot;&gt;&lt;/a&gt;流和FILE对象&lt;/h3&gt;&lt;h4 id=&quot;流的定向&quot;&gt;&lt;a href=&quot;#流的定向&quot; class=&quot;headerlink&quot; title=&quot;流的定向&quot;&gt;&lt;/a&gt;流的定向&lt;/h4&gt;&lt;p&gt;流可用于单字节或多字节字符集&lt;br&gt;未定项的流，一旦使用多字节就定向为多字节流，一旦使用单字节就定向为单字节流&lt;br&gt;&lt;code&gt;freopen&lt;/code&gt;和&lt;code&gt;fwide&lt;/code&gt;可以改变留的定向&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;wchar.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fwide&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FILE *fp, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;mode &amp;lt; 0，设置为单字节——字节定向&lt;br&gt;mode &amp;gt; 0，设置为多字节——宽定向&lt;br&gt;mode = 0，查询当前定向  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注： fwide 只能用来设置未定向的流  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-19</title>
    <link href="http://blog.sin5th.com/2017/04/19/2017-04-19/"/>
    <id>http://blog.sin5th.com/2017/04/19/2017-04-19/</id>
    <published>2017-04-19T03:37:25.000Z</published>
    <updated>2017-04-20T13:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-APUE"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>可移植的操作系统接口<br>定义的接口而非实现，因此不区分 <em>系统调用</em> 和 <em>库函数</em></p>
<h2 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h2><h3 id="进程访问文件时的层次结构"><a href="#进程访问文件时的层次结构" class="headerlink" title="进程访问文件时的层次结构"></a>进程访问文件时的层次结构</h3><ul>
<li>进程表（描述符+文件指针）</li>
<li>文件表（状态标记+当前偏移量+v节点指针）</li>
<li>v节点表（v节点信息+i节点信息+文件长度）</li>
</ul>
<a id="more"></a>
<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><blockquote>
<p>改变已打开文件的性质<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>它有5种功能：</p>
<ol>
<li>复制一个现有的描述符（cmd = F_DUPFD）</li>
<li>获得/设置文件描述符标记（cmd = F_GETFD/F_SETFD）</li>
<li>获得/设置文件状态标记（cmd = F_GETFL/F_SETFL）</li>
<li>获得/设置异步I/O所有权（cmd = F_GETOWN/F_SETOWN）</li>
<li>获得/设置记录锁（cmd = F_GETLK/F_SETLK/F_SETLKW）</li>
</ol>
<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><blockquote>
<p>I/O 操作的杂物箱<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    /* System V */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; /* BSD and Linux */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;   /* XSI STREAMS */</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> request, ...)</span></span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>上述是 ioctl 函数本身所要求的头文件。通常，还要求另外的设备专用头文件，这些头文件中可能会定义一组专用的命令。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="stat、fstat、lstat"><a href="#stat、fstat、lstat" class="headerlink" title="stat、fstat、lstat"></a>stat、fstat、lstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div></pre></td></tr></table></figure>
<p>stat 函数返回与明明文件有关的信息结构。<br>fstat 函数获取已在描述符 filedes 上打开文件的有关信息。<br>lstat 函数类似于 stat，但是当命名的文件是一个符号链接时，lstat 返回符号链接的有关信息。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>包含在 stat 结构的 st_mode 成员中，使用以下宏确定文件类型</p>
<ol>
<li>普通文件 S_ISREG</li>
<li>目录文件 S_ISDIR</li>
<li>块特殊文件 S_ISCHR</li>
<li>字符特殊文件 S_ISBLK</li>
<li>FIFO S_ISFIFO</li>
<li>套接字 S_ISSOCK</li>
<li>符号链接 S_ISLNK</li>
</ol>
<h3 id="确定-IPC-对象的类型的宏"><a href="#确定-IPC-对象的类型的宏" class="headerlink" title="确定 IPC 对象的类型的宏"></a>确定 IPC 对象的类型的宏</h3><ol>
<li>消息队列 S_TYPEISMQ</li>
<li>信号量 S_TYPEISSEM</li>
<li>共享存储对象 S_TYPEISSHM</li>
</ol>
<h3 id="用户ID和组ID"><a href="#用户ID和组ID" class="headerlink" title="用户ID和组ID"></a>用户ID和组ID</h3><ul>
<li>实际用户ID和组ID<ul>
<li>标识我们究竟是谁</li>
</ul>
</li>
<li>有效用户ID和组ID以及附加组ID<ul>
<li>决定我们的访问权限</li>
</ul>
</li>
<li>保存的设置用户ID和组ID<ul>
<li>执行程序时，对<strong>有效用户ID和组ID</strong>保存的副本</li>
</ul>
</li>
</ul>
<h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><table>
<thead>
<tr>
<th>st_mode 屏蔽</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>用户-读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户-写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户-执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组-读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组-写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组-执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他-读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他-写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他-执行</td>
</tr>
</tbody>
</table>
<p>进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试。所有者ID是文件的性质，有效ID和附加组ID是进程的性质。内核的测试是：</p>
<ol>
<li>若进程的有效用户ID是0，则允许访问</li>
<li>若进程的有效用户ID等于文件的所有者ID，则应用相应规则</li>
<li>若进程的有效小组ID或附加组ID之一等于文件的组ID，则应用相应规则</li>
<li>应用其他用户的规则</li>
</ol>
<p><code>access</code> 按实际用户ID和zuID进行访问权限检测</p>
<p>设置<strong>用户ID位</strong>，或<strong>组ID位</strong>。一般用来对执行二进制的进程进行提权，比如 passwd</p>
<p>设置<strong>粘住位</strong>的目录，对该目录有写权限的用户在满足下列条件之一的情况下，才能删除或更名该目录下的文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<h3 id="link、unlink、remove-和-rename"><a href="#link、unlink、remove-和-rename" class="headerlink" title="link、unlink、remove 和 rename"></a>link、unlink、remove 和 rename</h3><p>unlink 常被用来确保即使程序崩溃，它所创建的临时文件也不会留下来</p>
<h3 id="symlink-和-readlink"><a href="#symlink-和-readlink" class="headerlink" title="symlink 和 readlink"></a>symlink 和 readlink</h3><p>symlink 创建一个符号链接<br>readlink 打开链接本身（相反，open 跟随符号链接）  </p>
<h3 id="utime"><a href="#utime" class="headerlink" title="utime"></a>utime</h3><p>utime 修改文件的<strong>访问</strong>和<strong>修改</strong>时间</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;POSIX&quot;&gt;&lt;a href=&quot;#POSIX&quot; class=&quot;headerlink&quot; title=&quot;POSIX&quot;&gt;&lt;/a&gt;POSIX&lt;/h2&gt;&lt;p&gt;可移植的操作系统接口&lt;br&gt;定义的接口而非实现，因此不区分 &lt;em&gt;系统调用&lt;/em&gt; 和 &lt;em&gt;库函数&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;文件-I-O&quot;&gt;&lt;a href=&quot;#文件-I-O&quot; class=&quot;headerlink&quot; title=&quot;文件 I/O&quot;&gt;&lt;/a&gt;文件 I/O&lt;/h2&gt;&lt;h3 id=&quot;进程访问文件时的层次结构&quot;&gt;&lt;a href=&quot;#进程访问文件时的层次结构&quot; class=&quot;headerlink&quot; title=&quot;进程访问文件时的层次结构&quot;&gt;&lt;/a&gt;进程访问文件时的层次结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程表（描述符+文件指针）&lt;/li&gt;
&lt;li&gt;文件表（状态标记+当前偏移量+v节点指针）&lt;/li&gt;
&lt;li&gt;v节点表（v节点信息+i节点信息+文件长度）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-18</title>
    <link href="http://blog.sin5th.com/2017/04/18/2017-04-18/"/>
    <id>http://blog.sin5th.com/2017/04/18/2017-04-18/</id>
    <published>2017-04-18T06:53:13.000Z</published>
    <updated>2017-04-18T15:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读-APUE"><a href="#阅读-APUE" class="headerlink" title="阅读 APUE"></a>阅读 APUE</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>一般用整型常量代表错误原因，如 EACCES 为权限不足。<br>strerror(int) 将整型常量转化为错误字符串。<br>perror(const char *) 打印 <code>自定义字串: 错误字符串</code>。</p>
<h2 id="用户-组"><a href="#用户-组" class="headerlink" title="用户/组"></a>用户/组</h2><p>unix 中用户和组都是用32位整型表示的。<br>相比字符串，整型节省空间、检索高效。<br>getuid，getpid 分别返回<code>用户id</code>和<code>组id</code>。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>三种处理方式：忽略、系统默认、自定义。<br>signal 函数可以为信号注册处理函数。</p>
<a id="more"></a>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>unix 使用<code>日历时间</code>和<code>进程时间</code>两种时间值。</p>
<ul>
<li>日历时间：UTC</li>
<li>进程时间：CPU<ul>
<li>时钟时间</li>
<li>用户cpu时间</li>
<li>系统cpu时间</li>
</ul>
</li>
</ul>
<h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><p>对实现者而言，系统调用与库函数区别很大。<br>对使用者而言，没有太多差别。</p>
<h1 id="调整博客"><a href="#调整博客" class="headerlink" title="调整博客"></a>调整博客</h1><h2 id="给博客加个favicon"><a href="#给博客加个favicon" class="headerlink" title="给博客加个favicon"></a>给博客加个favicon</h2><p>用在线工具制作一个图标。<br>放到 source/favicon.png。<br>修改 themes/next/_config.yml，设置 <code>favicon: /favicon.png</code>。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中逆序对的总数。  </p>
<blockquote>
<p>归并排序，在归并过程中进行计数。</p>
</blockquote>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>我们把只包含因子2，3和5的数称作丑数。求按从小到大的顺序的第1500个丑数。</p>
<blockquote>
<p>用三个 index 分别表示2/3/5对应的丑数位置，保证:  </p>
<ol>
<li><code>2*i2&lt;x&lt;2*i2+2</code>;  </li>
<li><code>3*i3&lt;x&lt;3*i3+3</code>;  </li>
<li><code>5*i5&lt;x&lt;5*i5+5</code>;  </li>
</ol>
<p>其中x为当前的丑数，则下一个丑数一定出现在上述三个式子的右侧。</p>
</blockquote>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<blockquote>
<p>设 a、b、c 三个字符串。若<code>ab&gt;ba</code>，则<code>a&gt;b</code>；<br>将所有数字按照字母序递增，拼接后即是最小的数。</p>
</blockquote>
<h2 id="从1到n整数中1出现的次数"><a href="#从1到n整数中1出现的次数" class="headerlink" title="从1到n整数中1出现的次数"></a>从1到n整数中1出现的次数</h2><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读-APUE&quot;&gt;&lt;a href=&quot;#阅读-APUE&quot; class=&quot;headerlink&quot; title=&quot;阅读 APUE&quot;&gt;&lt;/a&gt;阅读 APUE&lt;/h1&gt;&lt;h2 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h2&gt;&lt;p&gt;一般用整型常量代表错误原因，如 EACCES 为权限不足。&lt;br&gt;strerror(int) 将整型常量转化为错误字符串。&lt;br&gt;perror(const char *) 打印 &lt;code&gt;自定义字串: 错误字符串&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;用户-组&quot;&gt;&lt;a href=&quot;#用户-组&quot; class=&quot;headerlink&quot; title=&quot;用户/组&quot;&gt;&lt;/a&gt;用户/组&lt;/h2&gt;&lt;p&gt;unix 中用户和组都是用32位整型表示的。&lt;br&gt;相比字符串，整型节省空间、检索高效。&lt;br&gt;getuid，getpid 分别返回&lt;code&gt;用户id&lt;/code&gt;和&lt;code&gt;组id&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h2&gt;&lt;p&gt;三种处理方式：忽略、系统默认、自定义。&lt;br&gt;signal 函数可以为信号注册处理函数。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>2017-04-17</title>
    <link href="http://blog.sin5th.com/2017/04/17/2017-04-17/"/>
    <id>http://blog.sin5th.com/2017/04/17/2017-04-17/</id>
    <published>2017-04-17T09:27:21.000Z</published>
    <updated>2017-04-28T05:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些异地灾备的文章"><a href="#一些异地灾备的文章" class="headerlink" title="一些异地灾备的文章:"></a>一些异地灾备的文章:</h2><ul>
<li><a href="http://tencentresearch.com/Article/lists/id/4115.html" target="_blank" rel="external">http://tencentresearch.com/Article/lists/id/4115.html</a></li>
<li><a href="http://coolnull.com/4381.html" target="_blank" rel="external">http://coolnull.com/4381.html</a></li>
</ul>
<h2 id="一些关于-raft-的文章"><a href="#一些关于-raft-的文章" class="headerlink" title="一些关于 raft 的文章:"></a>一些关于 raft 的文章:</h2><ul>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="external">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></li>
</ul>
<h2 id="一些关于-mysql-的文章"><a href="#一些关于-mysql-的文章" class="headerlink" title="一些关于 mysql 的文章:"></a>一些关于 mysql 的文章:</h2><ul>
<li><a href="http://www.jianshu.com/p/d877cbe9f0f0" target="_blank" rel="external">http://www.jianshu.com/p/d877cbe9f0f0</a></li>
<li><a href="http://www.cnblogs.com/ivictor/p/5735580.html" target="_blank" rel="external">http://www.cnblogs.com/ivictor/p/5735580.html</a></li>
</ul>
<a id="more"></a>
<h2 id="记一次修复-vagrant-与虚拟机的关联"><a href="#记一次修复-vagrant-与虚拟机的关联" class="headerlink" title="记一次修复 vagrant 与虚拟机的关联"></a>记一次修复 vagrant 与虚拟机的关联</h2><p>vagrant 不知为何失去了一个虚拟机的运行状态，执行 <code>vagrant up</code> 生成了新的虚拟机。</p>
<p>打开 virtual box 发现原来的虚拟机还在运行着，使用以下步骤恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 查看虚拟机列表，获取 ID</div><div class="line">$ VBoxManage list vms</div><div class="line">&quot;vm-sin5_test_xxxxxxx_xxxxxxx&quot; &#123;xxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&#125;</div><div class="line"></div><div class="line"># 将 ID 粘贴到文件</div><div class="line">echo -n &quot;xxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot; &gt; .vagrant/machines/test/virtualbox/id</div><div class="line">echo -n &quot;15:xxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot; &gt; .vagrant/machines/test/virtualbox/action_provision</div><div class="line"></div><div class="line"># 使用用户名/密码（vagrant/vagrant）登陆到虚拟机，修改 .ssh/authorized_keys</div><div class="line">让公钥与私钥（.vagrant/machines/test/virtualbox/private_key 对应</div><div class="line"></div><div class="line"># 恢复使用</div></pre></td></tr></table></figure>
<h2 id="几道面试题"><a href="#几道面试题" class="headerlink" title="几道面试题"></a>几道面试题</h2><h3 id="n个筛子的点数"><a href="#n个筛子的点数" class="headerlink" title="n个筛子的点数"></a>n个筛子的点数</h3><blockquote>
<p><strong>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印s所有可能的值出现的概率。</strong></p>
<p>n个筛子中K的出现次数 = (n-1)个筛子中 K-1 .. K-6 的次数之和。</p>
</blockquote>
<h3 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h3><blockquote>
<p><strong>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。</strong></p>
<p> 先翻转句子，再逐个单词翻转</p>
</blockquote>
<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干字符转移到字符串的尾部。</p>
<p>先翻转句子，再翻转前半部分，再翻转后半部分。</p>
</blockquote>
<h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h3><blockquote>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，是的它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。</p>
<p>头尾相加，如果比s小则左侧+1，如果比s大则右侧-1。</p>
</blockquote>
<h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h3><blockquote>
<p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。</p>
<p>small=1, big=2，如果 t = small + .. + big，t&gt;s时small++，t<s时big++。直到small>(1+s)/2</s时big++。直到small></p>
</blockquote>
<h3 id="数组中只出现1次的数字"><a href="#数组中只出现1次的数字" class="headerlink" title="数组中只出现1次的数字"></a>数组中只出现1次的数字</h3><blockquote>
<p>一个整型数组中，除了两个数字之外，其他的数字都出现了两次。求写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O（1）。</p>
<p>*相同数字异或为0。<br>将所有数字异或，得到两个不同数字的异或结果。找出这个结果中任意一个不为0的位，以此作为分界线将数组分为两组，按之前的方法找到只出现一次的数。</p>
</blockquote>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><blockquote>
<p>略</p>
</blockquote>
<h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><blockquote>
<p>略</p>
</blockquote>
<h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h3><blockquote>
<p>略</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些异地灾备的文章&quot;&gt;&lt;a href=&quot;#一些异地灾备的文章&quot; class=&quot;headerlink&quot; title=&quot;一些异地灾备的文章:&quot;&gt;&lt;/a&gt;一些异地灾备的文章:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tencentresearch.com/Article/lists/id/4115.html&quot;&gt;http://tencentresearch.com/Article/lists/id/4115.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coolnull.com/4381.html&quot;&gt;http://coolnull.com/4381.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一些关于-raft-的文章&quot;&gt;&lt;a href=&quot;#一些关于-raft-的文章&quot; class=&quot;headerlink&quot; title=&quot;一些关于 raft 的文章:&quot;&gt;&lt;/a&gt;一些关于 raft 的文章:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md&quot;&gt;https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一些关于-mysql-的文章&quot;&gt;&lt;a href=&quot;#一些关于-mysql-的文章&quot; class=&quot;headerlink&quot; title=&quot;一些关于 mysql 的文章:&quot;&gt;&lt;/a&gt;一些关于 mysql 的文章:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/d877cbe9f0f0&quot;&gt;http://www.jianshu.com/p/d877cbe9f0f0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/ivictor/p/5735580.html&quot;&gt;http://www.cnblogs.com/ivictor/p/5735580.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.sin5th.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>gdb 的初次使用</title>
    <link href="http://blog.sin5th.com/2017/04/16/gdb-%E7%9A%84%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.sin5th.com/2017/04/16/gdb-的初次使用/</id>
    <published>2017-04-16T13:57:05.000Z</published>
    <updated>2017-04-18T14:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>阅读 apue, 默写<1.1-简单ls实现>, 运行报段错误, 错误代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">  DIR *dp;</div><div class="line">  <span class="keyword">struct</span> dirent *dir;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">    err_quit(<span class="string">"usage: ls directory_name"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>]) == <span class="literal">NULL</span>)) &#123;</div><div class="line">    err_quit(<span class="string">"can't open directory %s"</span>, argv[<span class="number">1</span>]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> ((dir = readdir(dp) != <span class="literal">NULL</span>)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dir-&gt;d_name);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></1.1-简单ls实现></p>
<a id="more"></a>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>一时兴起, 想用 gdb 分析一下尸体.</p>
<ol>
<li><code>ulimit -c unlimited</code> 允许当前shell(bash)启动的进程输出core文件;</li>
<li><code>1.1-ls /tmp</code> 制造一个尸体.</li>
<li><code>gdb 1.1-ls core.16835</code> 开始观察.</li>
</ol>
<blockquote>
<p>gdb 可能会提示某些依赖缺失, 安装即可.</p>
</blockquote>
<p>观察到报错内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Program terminated with signal 11, Segmentation fault.</div><div class="line">#0  0x00000034e58a8936 in __readdir (dirp=0x0) at ../sysdeps/unix/readdir.c:45</div><div class="line">45	  __libc_lock_lock (dirp-&gt;lock);</div></pre></td></tr></table></figure></p>
<p>明显看出是 readdir 时传入了空指针.<br>回顾代码发现, 因为 <code>dp = opendir(argv[1]) == NULL</code> 这句代码先将 opendir 的结果和 NULL 进行了比较, 之后将值付给了 dp.<br>由于 /tmp 文件存在, opendir 返回值不为 NULL, dp 被赋值 false, 隐式转换为指向 0x0 的指针.</p>
<p>另外 <code>dir = readdir(dp) != NULL</code> 存在同样问题.</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>正确代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &quot;apue.h&quot;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;dirent.h&gt;</div><div class="line"></div><div class="line">int</div><div class="line">main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">  DIR *dp;</div><div class="line">  struct dirent *dir;</div><div class="line"></div><div class="line">  if (argc != 2) &#123;</div><div class="line">    err_quit(&quot;usage: ls directory_name&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if ((dp = opendir(argv[1])) == NULL) &#123;</div><div class="line">    err_quit(&quot;can&apos;t open directory %s&quot;, argv[1]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while ((dir = readdir(dp)) != NULL) &#123;</div><div class="line">    printf(&quot;%s\n&quot;, dir-&gt;d_name);</div><div class="line">  &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gdb 是个强大的调试工具, 这里只是简单地看了下引发崩溃的调用, 更多的用法将在以后的学习过程中记述.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;阅读 apue, 默写&lt;1.1-简单ls实现&gt;, 运行报段错误, 错误代码如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;apue.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;dirent.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  DIR *dp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dirent *dir;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    err_quit(&lt;span class=&quot;string&quot;&gt;&quot;usage: ls directory_name&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((dp = opendir(argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    err_quit(&lt;span class=&quot;string&quot;&gt;&quot;can&#39;t open directory %s&quot;&lt;/span&gt;, argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((dir = readdir(dp) != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, dir-&amp;gt;d_name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="clang" scheme="http://blog.sin5th.com/tags/clang/"/>
    
      <category term="gdb" scheme="http://blog.sin5th.com/tags/gdb/"/>
    
      <category term="apue" scheme="http://blog.sin5th.com/tags/apue/"/>
    
  </entry>
  
</feed>
