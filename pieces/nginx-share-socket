worker 进程从一个共享 socket 中 accept 连接，但这个 “共享” 是如何做到的呢

1. 由一个进程监听端口，然后将连接传递给其他进程
2. 使用 SO_REUSEPORT，利用内核处理负载均衡

为什么不用多线程？
多线程是一个解决方法。但是在多线程环境下，几乎所有的变量都是共享的，这需要很大的精力去确保这些变量要么没有共享、要么被多个线程交替地访问、要么完全地互斥。

目前没有哪门主流语言能原生地管理这种复杂度。

而使用多进程就可以很容易确保系统的正确性与稳定性。

这个问题很像黑、白名单之间的抉择。



为什么死掉的进程不释放端口占用


忽然想到 nginx-rtmp 中 exec 模块是否有内存泄漏，因为是用 fork+exec 执行指令，也就是说子进程的内存自然会随着进程上下文的替换被释放，不用太多考虑。


当连接到来时，所有的 worker 都被唤醒，然后竞争一个互斥锁。拿到锁的进程将继续处理链接，并在适当的时候释放锁。
（所以 nginx 的并发瓶颈之一可能是互斥锁的性能？）

node.js 中 worker 调用 server.listen 不直接监听端口，而是将请求通过 ipc 传送给 master，由 master 监听后将 handler 传递回子进程。
因此，多个 worker 可以监听同一端口。
